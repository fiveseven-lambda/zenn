---
title: "Hello, world!"
---

# `main` 関数
プログラムを書くとき，最低でもこれだけは書かなければなりません：
```rust
fn main() {
    
}
```
これだけ書いてコンパイルすると，実行しても何もせずそのまま正常終了するプログラムができます．

`fn main()` は，**`main` 関数**というものを表します．1 つのプログラムには必ずただ 1 つの `main` 関数が無くてはなりません．

プログラムの中身は， `fn main()` の後に続く波括弧 `{ }` の中に書きます．今回はここが空なので，何もしないプログラムということになります．
# 出力
## `println!` マクロ
次は，標準出力に `Hello, world!` と出力して，最後に改行し，終了するプログラムです．
```rust
fn main() {
    println!("Hello, world!");
}
```
`main` 関数の中に， `println!("Hello, world!");` と書かれた一行が存在します．これが「`Hello, world!` と出力し，最後に改行する」という意味になります．

`"Hello, world!"` のように， 2 つのダブルクォーテーションマーク `"` で囲まれた部分は，**文字列リテラル**と呼ばれます． `"` で囲むのを忘れてはいけません．

**`println!` マクロ**を使うと，標準出力に文字列を出力することができます．`println!( );` の丸括弧の中に文字列リテラルを書くと，その中身が出力され，最後に改行が行われます．一方，丸括弧の中に何も書かずただ `println!();` と書くと，改行だけが出力されます．

最後のセミコロン `;` は，そこで 1 つの文が終わることを意味します．

波括弧 `{ }` の中に複数の文を書くと，上から順に実行されることになります．
```rust
fn main() {
    println!("今すぐダウンロー");
    println!();
    println!("ド");
}
```
`main` 関数の中に，`;` で終わる文が 3 つあります．これをコンパイルすると，実行可能ファイル中に「`今すぐダウンロー` と出力して改行」「改行」「`ド` と出力して改行」という 3 つの処理が並び，実行するとこれらが**この順に**行われます．出力は
```-:標準出力
今すぐダウンロー

ド
```
となります．
## `print!` マクロ
`println!` マクロと違い， **`print!` マクロ**は最後に改行を出力しません．
```rust
fn main() {
    print!("こ");
    print!("ん");
    print!("に");
    print!("ち");
    print!("は");
}
```
と書くと，改行が無いため出力は
```-:標準出力
こんにちは
```
となります．
## `eprintln!` マクロ， `eprint!` マクロ
**`eprintln!` マクロ**は，標準出力ではなく標準エラー出力に出力し，最後に改行します． **`eprint!` マクロ**も標準エラー出力に出力しますが，最後に改行を出力しません．
```rust
fn main() {
    eprint!("An error ");
    eprintln!("occurred.");
}
```
```-:標準エラー出力
An error occured.
```

:::message
`println!` `eprintln!` の末尾の `ln` は， line （行）の略です． `eprintln!` `eprint!` の先頭の `e` は， error の頭文字です．
:::

# コメント
プログラム中には，その内容に関するコメントを書くことができます．コンパイラはコメントを無視するので，コメントを書いても作られる実行可能ファイルは変わりません．
```rust
fn main() {
    print!("Hi."); // Hi. と出力する．
    println!();
    /* このプログラムは
    Hi. と出力して改行したら
    終了します */
}
```
「`// Hi. と出力する．`」の部分と「`/* このプログラムは Hi. と出力して改行したら終了します */`」の部分がコメントです．このプログラムの動作は，コメントを取り除いた
```rust
fn main() {
    print!("Hi.");
    println!();
}
```
と同じということになります．

コメントには**ラインコメント**と**ブロックコメント**の 2 つがあります．「`// Hi. と出力する．`」がラインコメントで，「`/* このプログラムは Hi. と出力して改行したら終了します */`」がブロックコメントです．
## ラインコメント
`//` から行末までの間は，ラインコメントになります．行末までなので，一行分しか書くことができません．

ただし， `//` の直後が `/` あるいは `!` だと， `///` あるいは `//!` から始まる特別なコメントになってしまうため，普段のプログラム内でコメントを書くとき `//` の直後は `/` か `!` 以外の文字にしなければいけません．
## ブロックコメント
`/*` と `*/` で囲まれた部分は，ブロックコメントになります．ブロックコメントはラインコメントと違い，複数行にわたって書くことができます．

ブロックコメントは 2 重 3 重と入れ子にすることができます．すなわち `/* a /* b */ c */` は最初の `/*` から最後の `*/` までがコメントになります．

ただし， `/*` の直後が `*` あるいは `!` だと， `/**` あるいは `/*!` から始まる特別なコメントになってしまうため，普段のプログラム内でコメントを書くとき `/*` の直後は `*` か `!` 以外の文字にしなければいけません．

# インデント
ソースコード中で，スペースや改行といった「ホワイトスペース」と呼ばれる文字は，区切りとして以外の意味を持ちません．どういうことかというと，
```rust
fn main() {
    println!("Hello");
}
```
というコードは，余計なホワイトスペースを全て省いて
```rust
fn main(){println!("Hello");}
```
と書いても同じように動きます．この中で省けないのはただ 1 つ， `fn` と `main` を区切っているホワイトスペースだけです．

しかし，このようにホワイトスペースを削ると，コードが読みづらくなってしまいます．適度にホワイトスペースを入れてコードを読みやすくするための工夫の 1 つとして，ここでは**インデント**を紹介します．

インデントとは，行頭に空白文字を入れることで，行全体を右にずらすことです．これを， `{` と `}` に囲まれた部分について行います．

インデントを全く入れなかった場合
```rust
fn main() {
print!("Hello, ");
println!("world!");
}
```
となるところが，インデントとして 1 行につきスペースを 4 文字入れた場合
```rust
fn main() {
    print!("Hello, ");
    println!("world!");
}
```
となります． `{` と `}` で囲まれた部分をブロックといいますが，ブロックの中身をこうしてインデントしておくと，ブロックの始まりと終わりが見て分かりやすくなります．

:::message
VSCode を含む多くのエディタでは，自動的にインデントが行われるため，わざわざ手でスペースを入力する必要がありません．
:::

# エラー
## コンパイルエラー
次のコードをコンパイルしてみましょう．
```rust
fn main() {
    println("Hello");
}
```
`println!` の最後のエクスクラメーションマーク `!` を書いていません．これは文法上の誤りであり，**コンパイルエラー**になります．コンパイラは実行可能ファイルを生成せず，代わりにエラー内容を標準エラー出力にて説明します．

AtCoder のジャッジでは，CE というステータスがコンパイルエラーを意味します．
## 実行時エラー
**実行時エラー**は，コンパイル時に検出できないエラーです．

例えば，プログラム中で割り算をする場面が登場したとします．このときの割る数が，実行中に計算の結果として得られる値である場合，どんな数で割ることになるのかコンパイル時にはまだ分かりません．しかし，割る数がもし 0 だったら，計算不可能な 0 除算となってしまいます．これはコンパイル時に検出できないため，実行時にはじめてエラーが発生します．

次のコードをコンパイルしてみましょう．
```rust
fn main() {
    panic!();
}
```
**`panic!` マクロ**は，書くだけで実行時エラーを引き起こします．あえて実行時エラーにしたいときに使います（実行時エラーが起こったこと自体が情報をもつことがあり，[第 10 章](https://zenn.dev/toga/books/rust-atcoder/viewer/10-assert)で説明します）．

コンパイル自体は成功し，実行可能ファイルが作られます．しかし，それを実行すると実行時エラーが起こり，標準エラー出力にその旨が報告されます．

AtCoder のジャッジでは，RE というステータスが実行時エラーを意味します．

# エラーの読み方
コンパイルエラーや実行時エラーが起こったとき，エラーメッセージにそのエラーについての情報が書かれています．エラーメッセージを読むのは非常に大事ですので，必ず読みましょう．英語で書かれているため，読めない場合は機械翻訳などを利用しましょう．

## ケース 1
たとえば，さっきの間違ったコード
```rust
fn main() {
    println("Hello");
}
```
をコンパイルすると，
```
error[E0423]: expected function, found macro `println`
 --> src/main.rs:2:5
  |
2 |     println("Hello");
  |     ^^^^^^^ help: use `!` to invoke the macro: `println!`
```
というエラーが出力されます．

最初の `` expected function, found macro `println` `` というのは，「`println(...);` という文の中で `println` の部分には関数が来るはずだが，実際には `println` は関数ではなくマクロだった」という意味です（関数については[第 25 章](https://zenn.dev/toga/books/rust-atcoder/viewer/25-function)で説明します）．

それに続き `src/main.rs:2:5` と書いているのは，これが `src/main.rs` というファイル中の 2 行目 5 文字目で発生したエラーであるという意味です（AtCoder の提出ではファイル名は常に `src/main.rs` です）．よってソースコードの 2 行目周辺に着目することでエラーの原因が判明する可能性が高いです．

さらにその後に，
```
  |
2 |     println("Hello");
  |     ^^^^^^^ help: use `!` to invoke the macro: `println!`
```
と書かれています． 2 行目の `println` の部分について， `` help: use `!` to invoke the macro: `println!` ``，つまり「マクロを呼び出したいのであれば， `!` を付けて `println!` とするのはどうか」と提案されています．この help の指示に従うことでエラーが解決することは多いです．

## ケース 2
今度は次のコードをそっくりそのままコピーペーストしてコンパイルしてみましょう．
```rust
fn main() {
　println!("Hello");
}
```
見た目では非常に分かりづらいのですが， 2 行目のインデントが半角空白「` `」ではなく全角空白「`　`」になっています．空白文字として全角空白を用いることは許されていません．これをコンパイルすると
```
error: unknown start of token: \u{3000}
 --> src/main.rs:2:1
  |
2 | 　println!("Hello");
  | ^^
  |
help: Unicode character '　' (Ideographic Space) looks like ' ' (Space), but it is not
  |
2 |  println!("Hello");
  | --
```
というエラーが出力されます．`Unicode character '　' (Ideographic Space) looks like ' ' (Space), but it is not` というのは，「Unicode において Ideographic Space と名付けられている文字 '　' は Space という文字 ' ' に似ているが，これらは異なる文字である」という意味です．よって，全角空白を半角空白に直せば良いのだと分かります．

このように，エラーが起こったらまずはエラーメッセージを読むのが大事です．

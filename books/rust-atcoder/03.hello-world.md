---
title: "Hello, world!"
---
# `main` 関数
Rust のソースコードを書くとき，最低でもこれだけは書かなくてはなりません．
```rust
fn main() {

}
```
これだけ書いてそのままコンパイルすると，実行しても何もせず正常終了するだけのプログラムができます．

`fn main()` は，**`main` 関数**というものを表します．1 つのプログラムには必ずただ 1 つの `main` 関数が無くてはなりません．

プログラムの中身は，`fn main()` の後に続く波括弧 `{` 〜 `}` の中に書きます．今回はここが空なので，何もしないプログラムということになります．

# 出力
## `println!` マクロ
次のソースコードをコンパイルすると「標準出力 (stdout) に `Hello, world!` と出力して，最後に改行し，終了するプログラム」が作られます．
```rust
fn main() {
    println!("Hello, world!");
}
```
`fn main()` の後の波括弧 `{` 〜 `}` の中にプログラムの中身を書くといいました．今回，ここには `println!("Hello, world!");` と書かれた 1 行が存在します．これが「`Hello, world!` と出力し，最後に改行する」という意味になります．

ソースコード中において，`"Hello, world!"` のように 2 つのダブルクォーテーションマーク `"` で囲まれた部分は，**文字列リテラル**と呼ばれます． `"` で囲むのを忘れてはいけません．

**`println!` マクロ**を使うと，標準出力に文字列を出力させることができます．ソースコード中で `println!(` 〜 `);` の丸括弧の中に文字列リテラルを書いたものは，その中身（前後の `"` を除いた部分）を出力して最後に改行する処理へとコンパイルされます．一方，丸括弧の中に何も書かずただ `println!();` と書くと，改行だけが出力されます．

最後のセミコロン `;` は，そこで 1 つの文が終わることを意味します．

波括弧 `{` 〜 `}` の中に複数の文が書かれていると，それらを*上から順に*実行するプログラムとなります．たとえば次のソースコードを見てください．
```rust
fn main() {
    println!("今すぐダウンロー");
    println!();
    println!("ド");
}
```
`main` 関数の中に，`;` で終わる文が 3 つあります．これをコンパイルすると，「`今すぐダウンロー` と出力して改行」「改行」「`ド` と出力して改行」という 3 つの処理を*この順に*行うプログラムができます．実行すると，標準出力には
```:stdout
今すぐダウンロー

ド
```
と出力されます．

:::message
コンピュータ上では，改行も文字の一種として扱われます．上の例の標準出力では `今すぐダウンロー` の後に 2 回改行してから `ド` が出力されていますが，これは「改行という特殊な文字」が 2 つ挟まれたものとみなされています．
:::

## `print!` マクロ
`println!` マクロと違い， **`print!` マクロ**は最後に改行を出力しません．
```rust
fn main() {
    print!("こ");
    print!("ん");
    print!("に");
    print!("ち");
    print!("は");
}
```
と書くと，改行が無いため出力は 1 行で
```:stdout
こんにちは
```
となります．
## `eprintln!` マクロ， `eprint!` マクロ
**`eprintln!` マクロ**は，標準出力ではなく標準エラー出力 (stderr) に出力し，最後に改行します．**`eprint!` マクロ**も標準エラー出力に出力しますが，最後に改行を出力しません．
```rust
fn main() {
    eprint!("An error ");
    eprintln!("occurred.");
}
```
```:stderr
An error occured.
```

:::message
`println!` `eprintln!` の末尾の `ln` は， line （行）の略です． `eprintln!` `eprint!` の先頭の `e` は， error の頭文字です．
:::
# コメント
ソースコード中には，その内容に関する**コメント**を書くことができます．コンパイラはコメントを無視するので，コメントを書いてもできるプログラムの動作は変わりません．
```rust
fn main() {
    print!("Hi."); // Hi. と出力する．
    println!();
    /* このプログラムは
    Hi. と出力して改行したら
    終了します */
}
```
「`// Hi. と出力する．`」の部分と「`/* このプログラムは Hi. と出力して改行したら終了します */`」の部分がコメントです．このソースコードは，コメントを取り除いた
```rust
fn main() {
    print!("Hi.");
    println!();
}
```
と同じプログラムへコンパイルされます．

コメントには**ラインコメント**と**ブロックコメント**の 2 つがあります．「`// Hi. と出力する．`」がラインコメントで，「`/* このプログラムは Hi. と出力して改行したら終了します */`」がブロックコメントです．
## ラインコメント
`//` から行末までの間は，ラインコメントになります．行末までなので，1 行分しか書くことができません．
## ブロックコメント
`/*` と `*/` で囲まれた部分は，ブロックコメントになります．ブロックコメントはラインコメントと違い，複数行にわたって書くことができます．

ブロックコメントは 2 重 3 重と入れ子にすることができます．すなわち `/* a /* b */ c */` は最初の `/*` から最後の `*/` までがコメントになります．

# インデント
ソースコード中で，スペースや改行といった「ホワイトスペース」と呼ばれる文字は，区切りとして以外の意味を持ちません．どういうことかというと，
```rust
fn main() {
    println!("Hello");
}
```
というソースコードは，必要でないホワイトスペースを全て省いて
```rust
fn main(){println!("Hello");}
```
と書いても，同じように `hello` とだけ出力するプログラムになります．この中で省けないのはただ 1 つ， `fn` と `main` を区切っているホワイトスペースだけです．

しかし，このように空白を削りすぎると，ソースコードが読みづらくなってしまいます．適度に空白を入れてコードを読みやすくするための工夫の 1 つとして，ここでは**インデント**を紹介します．

インデントとは，行頭に空白文字を入れることで，行全体を右にずらすことです．これを， `{` と `}` に囲まれた部分について行います．

インデントを全く入れなかった場合
```rust
fn main() {
print!("Hello, ");
println!("world!");
}
```
となるところが，インデントとして 1 行につきスペースを 4 文字入れた場合
```rust
fn main() {
    print!("Hello, ");
    println!("world!");
}
```
となります． `{` と `}` で囲まれた部分をブロックといいますが，ブロックの中身をこうしてインデントしておくと，ブロックの始まりと終わりが見て分かりやすくなります．

:::message
VSCode を含む多くのエディタでは，自動的にインデントが行われるため，わざわざ手でスペースを入力する必要がありません．
:::

# コンパイルエラー
次のソースコードをコンパイルしてみましょう．
```rust
fn main() {
    println("Hello");
}
```
`println!` の最後のエクスクラメーションマーク `!` を書いていません．これは文法上の誤りであり，コンパイルしようとすると**コンパイルエラー**が出ます．コンパイラは実行可能ファイルを生成せず，代わりにエラー内容を標準エラー出力にて説明します．

:::message
AtCoder に提出したソースコードがコンパイルエラーとなった場合，CE というステータスが表示されます．
:::

## エラーメッセージ
コンパイラは，ソースコード上に誤りを見つけると標準エラー出力に**エラーメッセージ**を出力します．エラーメッセージにはその誤りに関する情報が書かれており，非常に大事ですので，表示されたら必ず読みましょう．英語で書かれているため，分からなければ機械翻訳などを活用しましょう．

### ケース 1
たとえば，上で登場した間違ったソースコード
```rust
fn main() {
    println("Hello");
}
```
をコンパイルしようとすると，コンパイラは
```
error[E0423]: expected function, found macro `println`
 --> src/main.rs:2:5
  |
2 |     println("Hello");
  |     ^^^^^^^ help: use `!` to invoke the macro: `println!`
```
というエラーメッセージを出力します．

最初の `` expected function, found macro `println` `` というのは，「`println(...);` という文の中で `println` の部分には関数が来るはずだが，実際には `println` は関数ではなくマクロだった」という意味です（関数については[第 21 章](https://zenn.dev/toga/books/rust-atcoder/viewer/function)で説明します）．

それに続き `src/main.rs:2:5` と書いているのは，これが `src/main.rs` というファイル中の 2 行目 5 文字目で発生したエラーであるという意味です（AtCoder の提出ではファイル名は常に `src/main.rs` です）．よってソースコードの 2 行目周辺に着目することでエラーの原因が判明する可能性が高いです．

さらにその後に，
```
  |
2 |     println("Hello");
  |     ^^^^^^^ help: use `!` to invoke the macro: `println!`
```
と書かれています． 2 行目の `println` の部分について， `` help: use `!` to invoke the macro: `println!` ``，つまり「マクロを呼び出したいのであれば， `!` を付けて `println!` とするのはどうか」と提案されています．この help の指示に従うことでエラーが解決することは多いです．

### ケース 2
今度は次のソースコードをそっくりそのままコピーペーストしてコンパイルしてみましょう．
```rust
fn main() {
　println!("Hello");
}
```
見た目では非常に分かりづらいのですが， 2 行目のインデントが半角空白「` `」ではなく全角空白「`　`」になっています．ホワイトスペースに全角空白を用いることは許されていません．これをコンパイルしようとすると，コンパイラは
```
error: unknown start of token: \u{3000}
 --> src/main.rs:2:1
  |
2 | 　println!("Hello");
  | ^^
  |
help: Unicode character '　' (Ideographic Space) looks like ' ' (Space), but it is not
  |
2 |  println!("Hello");
  | --
```
というエラーメッセージを出力します．`Unicode character '　' (Ideographic Space) looks like ' ' (Space), but it is not` というのは，「Unicode において Ideographic Space と名付けられている文字『`　`』は Space という文字『` `』に似ているが，これらは異なる文字である」という意味です．よって，全角空白を半角空白に直せば良いのだと分かります．

このように，コンパイルエラーが起こったらまずはエラーメッセージを読むのが大事です．

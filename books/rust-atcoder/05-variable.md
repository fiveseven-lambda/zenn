---
title: "変数と型"
---

# 変数
コンピュータ上で動くプログラムは，実行時にコンピュータの**メモリ**を利用できます．ある計算の結果をメモリに書き込んでおいて，それを後で別の計算に用いることができます．

たとえば，ある正方形の 1 辺の長さを求め，続いてその周長と面積も求めたいとします．このとき，求めた 1 辺の長さをメモリに記録しておけば，次に周長と面積を求めるときは，記録された値を読み出して再利用できるわけです．

このように値を読み書きできる場所が，たくさん並んだものがメモリです．1 つの値を記録するたびに，メモリ上のどこか 1 ヶ所を選んで使うことになります．

Rust のソースコード中で**変数**を使うと，このようにメモリを使って値を再利用するプログラムを書くことができます．

以下のサンプルコードを用いて，変数について説明します．これは，1 辺の長さが 5 の正方形について，まず 5 という整数を記録し，それを使ってその正方形の周長と面積を計算して出力するプログラムです．
```rust
fn main() {
    let length;
    length = 5;
    println!("一辺の長さは{}", length);
    println!("周長は{}", length * 4);
    println!("面積は{}", length * length);
}
```

## 宣言
メモリ上のある 1 ヶ所にソースコード上で名前を付けるというのが，変数の考え方です．名前を付けた場所に値を記録しておけば，使うときはその名前を指定することで同じ場所から値を読み出すことができます．

変数は，使う前にその名前を**宣言**する必要があります．上のサンプルコードでは，以下の 1 行で `length` という名前の変数を宣言しています．
```rust
let length;
```
宣言をするには，`let` の後に 1 つ以上空白をあけてから変数名を書き，最後にセミコロン `;` を付けます．セミコロン `;` を忘れないようにしましょう．

この宣言によって，ソースコード中ではこれ以降 `length` という名前が使えるようになります．複数回登場する `length` は，みなメモリ上の同じ箇所を指します．

## 代入
次に現れる以下の 1 行は，メモリに整数 5 を書き込む処理へとコンパイルされます．
```rust
length = 5;
```
これを「変数 `length` に値 5 を**代入**する」といいます．

変数への代入は 1 度しか行えません．2 回以上の代入，すなわち
```rust:コンパイルエラー
length = 5;
length = 10;
```
のように書くことはできません．

## 使用
`length` に値を代入すると，それ以降式の中で `length` を使えるようになります．これらは，メモリに書き込まれた値 5 を読み出して使うようにコンパイルされます．
```rust
println!("一辺の長さは{}", length);
println!("周長は{}", length * 4);
println!("面積は{}", length * length);
```

`length` に整数 5 が代入されていれば，出力は
```:stdout
一辺の長さは5
周長は20
面積は25
```
となります．

数学では $x \times 2$ を $2x$ とも書きますが，コードの中で `x * 2` を `2 x` や `x 2` などと書くことはできません．
## コンパイル後の変数名
変数を使って書かれたソースコードがコンパイルされると，代入はメモリへの書き込み，使用はメモリからの読み出しとなります．しかしこのとき，ソースコード上で変数に付いていた名前は，失われます．代わりに，書き込みと読み出しが，メモリ上の同じ場所に対して行われるようにコンパイルされます．よって，変数にどんな名前を付けても，できる実行可能ファイルにおいて代入や使用に対応する部分の中身は変わりません．

# 変数名
変数に付ける名前は，その変数に代入される値のもつ意味に基づいて，適切に選びます．このとき，以下のルールと慣例が存在します．

## 変数名のルール
変数名には， `a` から `z` までの小文字アルファベット， `A` から `Z` までの大文字アルファベット， `0` から `9` までの数字，そしてアンダースコア `_` が使えます．たとえば， `hoge` ， `expo2025` ， `very_long_name` などが変数名として使えます．

ただし，次のような名前は使えません．
- `551horai` のように，先頭が数字であるようなものは変数名として使えません．
- 単独のアンダースコア `_` は特別な意味をもつため，普通の変数名としては使えません． `_x` や `__` （アンダースコア 2 つ）であれば使えます．
- `crate` `self` `super` `Self` の 4 つは変数名として使えません．
- `fn` や `let` など，いくつかの名前は**キーワード**として予約されており，変数名として使えません．どうしても使いたい場合は，先頭に `r#` を付けて `r#fn` とする必要があります．
  キーワードの一覧は[ここ](https://doc.rust-lang.org/reference/keywords.html)にあります．
:::message
Rust 1.53.0 から， `あア漢` のようなアルファベット以外の文字も変数名に使えるようになりました．ただし，AtCoder のジャッジ環境（現在 Rust 1.42.0）では使えません．
:::
## 慣例
今後，変数以外に名前を付けるときにも，上と同じルールが登場することがあります．たとえば定数や構造体などです．ルールを満たしていればどんな名前を付けてもエラーにはならないのですが，変数と定数などを区別する目的で，変数名の付け方には以下のような慣例が定められています．
### 先頭は大文字にしない
変数に名前を付けるとき，先頭に大文字アルファベットは使用しません．一方，定数や構造体に付ける名前は先頭を大文字にします．
### スネークケースにする
1 つの変数名の中に空白を挟むことはできないので，たとえば "max height"（高さの最大値）を表す変数に対して名前を付けるときは， max と height をアンダースコア `_` でつないで `max_height` とします．このように，複数の単語を `_` でつないで変数名にするやり方を**スネークケース**といいます．一方，構造体などに名前を付ける際には `MaxHeight` のように大文字と小文字を使って単語の区切りを表します．これを**キャメルケース**といいます．
### 使用しない変数は `_` で始める
代入しただけで使わない変数がある場合は，名前をアンダースコア `_` から始めます．

# 型
コンピュータの中では，すべての値が 0 と 1 の並びで表されます．よってメモリも，0 か 1 のどちらかを記憶するセルがたくさん並んだものです．整数や浮動小数点数は，0 と 1 の並びに変換されたあと，メモリ上で連続したいくつかのセルにまたがって記録されます．

1 つのセルが表す 0 か 1 の値を**ビット**といいます．1 つのビットを使うと 2 つの値 0, 1 を区別できるので，32 個のビットを使うと $2^{32}$ 通り，64 個のビットを使うと $2^{64}$ 通りの値が区別できます．

たとえば，整数 10 は 2 進法で 1010 なので，コンピュータの中では（32 ビット整数の場合） `00000000000000000000000000001010` のように表されます．

一方，浮動小数点数の 2.5 は（単精度の場合） `01000000001000000000000000000000` のように表されます．これを 2 進法の整数として解釈すると， 1075838976 になってしまいます．

つまり，同じ 0 と 1 の並びでも，整数として解釈した場合と浮動小数点数として解釈した場合では表すものが異なります．よって，解釈の仕方を事前に決めておかないと，書き込んだり読み出したりするときに困るわけです．

この解釈の仕方を決めるのが，変数の**型**です．すべての変数は何らかの型を持っていて，メモリ上の書き込みや読み出しはその型に従って行われます．

たとえば以下のような型があります．
| 型 | ビット数 | 説明 |
| -- | -- | -- |
| `i32` | 32ビット | 整数を扱うことができる． |
| `u32` | 32ビット | $0$ 以上の整数だけを扱うことができる． |
| `f64` | 64ビット | 小数も扱うことができる． |

他には[このような型](https://doc.rust-lang.org/std/index.html#primitives)があります．

## 型注釈
変数の宣言において
```rust
let hoge: i32;
```
と書くと，変数 `hoge` は `i32` という型になります．このように変数の宣言において型を明記することを，**型注釈**といいます．

## 異なる型の代入や計算
異なる型の間で代入を行おうとすると，コンパイルエラーになります．たとえば，
```rust:コンパイルエラー
fn main() {
    let hoge: f64;
    hoge = 2;
}
```
というコードは
```
error[E0308]: mismatched types
 --> src/main.rs:3:12
  |
3 |     hoge = 2;
  |            ^
  |            |
  |            expected `f64`, found integer
  |            help: use a float literal: `2.0`
```
というエラーになります．``expected `f64`, found integer`` は「`hoge` が `f64` 型なので， `=` の右辺にも `f64` 型の値が来るはずだったが，実際には整数値があった」という意味です． `` use a float literal: `2.0` ``は「整数リテラル `2` の代わりに浮動小数点数リテラル`2.0` を使ってはどうか」という意味です．実際， `2` を `2.0` に書き換えることで，このコードは正しく動くようになります．

足し算などの演算も，左右の型が異なるとコンパイルエラーになります．
```rust:コンパイルエラー
fn main() {
    let x: i32 = -10;
    let y: u32 = 10;
    println!("{}", x + y);
}
```
エラーメッセージは次のようになります．
```
error[E0308]: mismatched types
 --> src/main.rs:4:24
  |
4 |     println!("{}", x + y);
  |                        ^ expected `i32`, found `u32`
```
``expected `i32`, found `u32` `` は「`i32` が来るはずだったが，実際には `u32` があった」という意味です．

## 静的型付け
変数名と同じように，変数のもつ型の情報もコンパイルの過程で失われます．代わりに，書き込みと読み出しがすべて同じ型の解釈に基づいて行われるようにコンパイルされます．

しかし例えば，整数の足し算と，浮動小数点数の足し算は，機械語の上で異なります．よって，ソースコード中に足し算が現れたとき，コンパイラはそれが整数の足し算であれば整数の足し算を表す機械語へと，浮動小数点数の足し算であれば浮動小数点数の足し算を表す機械語へと翻訳することになります．

このことから，コンパイルを正しく行うためには，すべての変数の型がコンパイル時に判明しなければいけないと分かります．実行時に型の決まる変数や，実行中に型の変わる変数は存在しえません．このことを，**静的型付け**といいます．

## 型推論
最初の例に戻ってみましょう．
```rust
fn main() {
    let length;
    length = 5;
    println!("一辺の長さは{}", length);
    println!("周長は{}", length * 4);
    println!("面積は{}", length * length);
}
```
コード中に `length` の型が書かれていません．では `length` の型は何でしょうか．

実は，`length` の型を明示的に書かなくても，その後の `length = 5;` という文から `length` の型が推測されるようになっています．これを**型推論**といいます．今回は整数値の 5 が代入されているので， `length` は `i32` 型であればよいと判断されます．

ではこんなコードを書いたらどうなるでしょうか．
```rust:コンパイルエラー
fn main() {
    let hoge;
}
```
型注釈が無く，その後に `hoge` の型を推論する材料もないため，型推論ができずエラーになります．
```
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let hoge;
  |         ^^^^ consider giving `hoge` a type
```
`type annotations needed` は「型注釈が必要である」という意味です． ``consider giving `hoge` a type``は「変数 `hoge` に型を与えてみてはどうか」という提案です．
# 宣言と代入
宣言と代入は 1 つの文にまとめて書くことができます．
```rust
let x = 5;
```
これは，`let x;` の直後に `x = 5;` と書いたのと同じ意味になります．英語の "Let $x = 5$."（$x = 5$ とする）という表現と同じ形になります．

ここにさらに型注釈をくわえる場合は
```rust
let x: i32 = 5;
```
となります．
# 未初期化の変数
ソースコード中で，変数を使用する前に，その変数への代入が行われていなかった場合，コンパイルエラーになります．
```rust:コンパイルエラー
fn main() {
    let hoge: i32;
    println!("{}", hoge);
}
```
このように，まだ値が代入されていない変数は，**未初期化**であるといいます．コンパイルエラーは以下の通りです．
```
error[E0381]: borrow of possibly-uninitialized variable: `hoge`
 --> src/main.rs:3:20
  |
3 |     println!("{}", hoge);
  |                    ^^^^ use of possibly-uninitialized `hoge`
```
`possibly-uninitialized variable` というのが「未初期化である可能性のある変数」という意味です．
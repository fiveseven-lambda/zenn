---
title: "ループのラベルと値返し"
---
# 2 重ループとラベル
## 2 重ループ
`for` 式のブロック中に，さらに `for` 式を書くことができます．
```rust
fn main() {
    for i in 0..4 {
        for j in 0..i {
            print!("({}, {}) ", i, j);
        }
        println!();
    }
}
```
1. 外側のループ 1 周目： $i = 0$ ．
   1. 範囲 `0..0` は空なので，内側のループは一度も実行されません．
   1. 改行が出力されます．
1. 外側のループ 2 周目： $i = 1$ ．
   1. `0..1` の中の各 `j` について内側のループが実行されます．
   1. 内側のループ 1 周目： $j = 0$ ．
      1. `(1, 0) ` と出力されます．
   1. 改行が出力されます．
1. 外側のループ 3 周目： $i = 2$ ．
   1. `0..2` の中の各 `j` について内側のループが実行されます．
   1. 内側のループ 1 周目： $j = 0$ ．
      1. `(2, 0) ` と出力されます．
   1. 内側のループ 2 周目： $j = 1$ ．
      1. `(2, 1) ` と出力されます．
   1. 改行が出力されます．
1. 外側のループ 4 周目： $i = 3$ ．
   1. `0..3` の中の各 `j` について内側のループが実行されます．
   1. 内側のループ 1 周目： $j = 0$ ．
      1. `(3, 0) ` と出力されます．
   1. 内側のループ 2 周目： $j = 1$ ．
      1. `(3, 1) ` と出力されます．
   1. 内側のループ 3 周目： $j = 2$ ．
      1. `(3, 2) ` と出力されます．
   1. 改行が出力されます．

よって実行すると次のように出力されます．
```:stdout

(1, 0) 
(2, 0) (2, 1) 
(3, 0) (3, 1) (3, 2) 
```
`0..0` や `2..1` のような空の範囲だと， `for` 式のブロックは一度も実行されません．よって一行目は空のまま改行だけが行われます．

## `break`
次は，このコードに `break;` を含む `if` 式を追加して
```rust
fn main() {
    for i in 0..4 {
        for j in 0..i {
            if i * j >= 2 {
                break;
            }
            print!("({}, {}) ", i, j);
        }
        println!();
    }
}
```
としてみます．出力はどうなるでしょうか？

`break;` によって終了するのは，*一番内側のループただ一つ*です．

よって，出力は次のようになります．
```:stdout

(1, 0) 
(2, 0) 
(3, 0) 
```
$i = 2$，$j = 1$ のときに $ij \geq 2$ となるため， `(2, 1) ` が出力される前に内側のループが終了しますが，外側のループは続いているため $i = 3$ の場合が実行されます．
## ラベル
一方， `break;` によって外側のループを終了し，出力が
```:stdout

(1, 0) 
(2, 0) 
```
となるようにしたいときは，ループに**ラベル**を付けます．

```rust
'outer: for i in 0..4 {
```

アポストロフィ `'` で始まっている部分 `'outer` がラベルです．このように書くと， `for` 式に `'outer` という名前を付けることができます．ラベルは先頭に `'` が付いていなければなりません．また，ラベルと `for` の間にコロン `:` を書くのを忘れてはいけません．

こうして付けた名前は， `break` 式や `continue` 式で使うことができます．
```rust
fn main() {
    'outer: for i in 0..4 {
        for j in 0..i {
            if i * j >= 2 {
                println!();
                break 'outer;
            }
            print!("({}, {}) ", i, j);
        }
        println!();
    }
}
```
`break 'outer;` によって終了するのは，ラベル `'outer` が付いた外側の `for` 式です．よって出力
```:stdout

(1, 0) 
(2, 0) 
```
が得られます．
# 値を返す `loop` 式
`loop` 式の中では， `break` の直後に式を書くと値を返すことができます．
```rust
use proconio::input;

fn main() {
    let value = loop {
        input! {
            x: i32,
        }
        if x > 0 {
            println!("{}", x * 2);
        } else {
            break x; // x の値を返す
        }
    }; // セミコロンが必要
    println!("value: {}", value);
}
```
前の章の `loop` 式の例と同様に，負であるようなものを読み込んだ時点でループが終了しますが，そのときに `x` の値を返しています．これが `value` に代入され，最後に `println!` マクロで出力されています．

よって入力が
```:stdin
3 10 6 -5 2 7
```
であれば
```:stdout
6
20
12
value: -5
```
と出力されます．

## ラベル
ラベル付き `break` でさらに値を返すには，
```rust
break ラベル 式;
```
とします．次は「入力を受け取って，素数ならまた次の入力を受け取り，合成数なら最小の素因数を出力して終了する」プログラムです．
```rust
use proconio::input;

fn main() {
    let factor = 'input: loop {
        input! {
            x: i32,
        }
        for i in 2.. {
            // 2 以上の各整数について，
            // x を割り切るか順に調べる
            if i * i > x {
                // i が x の平方根より大きくなったら
                // それ以上調べても意味がない
                break;
            } else if x % i == 0 {
                // i は x を割り切る最小の整数
                break 'input i;
            }
        }
    };
    println!("{}", factor);
}
```
14 行目の `break;` では内側のループ， 17 行目の `break 'input i;` では外側のループが終了します．

たとえば入力が
```
7 11 5 9 13 8
```
なら，このうち `7 11 5 9` までを読み込んで `3` と出力します．

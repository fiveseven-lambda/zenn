---
title: "再帰関数とスタック領域"
---
# 再帰関数
関数の中で，その関数自身を呼び出すことができます．
```rust
fn fnc() {
    // ここで fnc() を呼び出す
}
```
内部で自分自身を呼び出すような関数を，**再帰関数**といいます．

## 階乗
前の章で出てきた階乗の定義を確認します．$0$ 以上の整数 $n$ について， $1$ 以上 $n$ 以下の整数をすべてかけ合わせた数を $n$ の階乗といい， $n!$ と書きます．ただし $n = 0$ のときについては $0! = 1$ と定義されます．

`i32` 型の整数 `n` を受け取って，`n` の階乗を返す関数 `fact` は，`for` 式を使う代わりに，再帰関数として以下のように書くこともできます．
```rust
fn fact(n: i32) -> i32 {
    if n == 0 {
        1
    } else {
        fact(n - 1) * n
    }
}
```
まず，引数 `n` を 3 として `fact(3)` を呼び出すとどうなるか追ってみましょう．

1. 呼び出された `fact(3)` の中では $n = 3$ である．
1. `n == 0` が `false` なので， `else` ブロックが実行される．
1. `fact(n - 1)` すなわち `fact(2)` が呼び出される．
   1. 呼び出された `fact(2)` の中では $n = 2$ である．
   1. `n == 0` が `false` なので， `else` ブロックが実行される．
   1. `fact(n - 1)` すなわち `fact(1)` が呼び出される．
      1. 呼び出された `fact(1)` の中では $n = 1$ である．
      1. `n == 0` が `false` なので， `else` ブロックが実行される．
      1. `fact(n - 1)` すなわち `fact(0)` が呼び出される．
         1. 呼び出された `fact(0)` の中では $n = 0$ である．
         1. `n == 0` が `true` なので， `if` ブロックが実行される．
         1. `fact(0)` の返り値は 1 となる．
      1. `fact(1)` の返り値は， `fact(0) * 1` すなわち 1 となる．
   1. `fact(2)` の返り値は， `fact(1) * 2` すなわち 2 となる．
1. `fact(3)` の返り値は， `fact(2) * 3` すなわち 6 となる．

ちゃんと， $3! = 6$ が返ってきています．

## 再帰関数の書き方

再帰関数を書くときには，まず `fact(a)` と `fact(b)` の間に成り立つ何らかの関係式を考えます．今回使った関係式は，

- $n! = (n - 1)! \times n$ （ $n = 1, 2, 3, \ldots$ ）

です． $(n - 1)!$ の値が分かれば，そこに $n$ をかけることで $n!$ の値も分かります．つまり， `fnc(n)` の中で `fnc(n - 1)` を呼び出すと， `fnc(n - 1) * n` を `fnc(n)` の返り値とすることができます．しかし，

```rust
fn fact(n: i32) -> i32 {
    fact(n - 1) * n
}
```

とは書けません．こう書くと， `fact(3)` が `fact(2)` を呼び出し， `fact(2)` が `fact(1)` を呼び出し， `fact(1)` が `fact(0)` を呼び出し， `fact(0)` が `fact(-1)` を呼び出し， `fact(-1)` が `fact(-2)` を呼び出し……というように，呼び出しが無限に続いてしまいます．

関係式 $n! = (n - 1)! \times n$ が成り立つのは， $n \geq 1$ のときでした．よって $n = 0$ のときは `fact(n - 1) * n` とすることができないので，代わりに $0! = 1$ を返すようにします．こうすると， `fact(3)` から始まった呼び出しのループは， `fact(1)` が `fact(0)` を呼び出したところで終了することになります．このように，再帰を終了させるために作られる場合分けをベースケースといいます．

```rust
fn fact(n: i32) -> i32 {
    if n == 0 {
        1 // ベースケース
    } else {
        fact(n - 1) * n
    }
}
```

## 各桁の和
以下の `digit_sum` は，与えられた整数 `n` に対し，`n` の各桁の和を再帰的に計算する関数です．たとえば `n` が $6318$ なら，各桁の和は $6 + 3 + 1 + 8 = 18$ です．まず $6318$ を 1 の位の $8$ と残りの $631$ に分け，再帰呼出しによって $631$ の各桁の和 $10$ を求めてから，そこに $8$ を加えることで全体の和 $18$ を得ています．
```rust
fn digit_sum(n: i32) -> i32 {
    if n == 0 {
        return 0;
    }
    let last_digit = n % 10;
    let higher_digits_sum = digit_sum(n / 10);
    let result = higher_digits_sum + last_digit;
    println!(
        "{} の各桁の和は {} + {} = {}",
        n, higher_digits_sum, last_digit, result
    );
    result
}

fn main() {
    assert_eq!(digit_sum(6318), 18);
}
```
分かりやすいように途中経過も出力しています．$n = 6318$ の例であれば
```:stdout
6 の各桁の和は 0 + 6 = 6
63 の各桁の和は 6 + 3 = 9
631 の各桁の和は 9 + 1 = 10
6318 の各桁の和は 10 + 8 = 18
```
と出力され，再帰的に計算が行われる様子が見て取れます．

## 最大公約数
$0$ 以上の整数 $m$，$n$ について，$m$ の約数でもあり $n$ の約数でもあるような最大の整数を $m$ と $n$ の**最大公約数**といいます．ただし，$m = 0$ であれば最大公約数は $n$ であるとし，$n = 0$ であれば最大公約数は $m$ であるとします．

例として $m = 18$，$n = 30$ の場合を考えます．$18$ の約数は $1, 2, 3, 6, 9, 18$ であり，$30$ の約数は $1, 2, 3, 5, 6, 10, 15, 30$ です．これらに共通の約数は $1, 2, 3, 6$ であり，そのうち最大の $6$ が $18$ と $30$ の最大公約数となります．

このように $m$ の約数と $n$ の約数をそれぞれ列挙したあと共通のものを探せば，$m$ と $n$ の最大公約数を求めることができますが，**ユークリッドの互除法**と呼ばれる手法を使うと，より素早く最大公約数を計算することができます．以下がそのコードです．

```rust
fn gcd(m: i32, n: i32) -> i32 {
    if n == 0 {
        m
    } else {
        gcd(n, m % n)
    }
}

fn main() {
    assert_eq!(gcd(18, 30), 6);
    assert_eq!(gcd(15, 24), 3);
}
```

$n = 0$ のとき，定義より $m$ が最大公約数なので，`m` を返しています．$n \ne 0$ のとき，$m$ を $n$ で割った余りを $r$ とおくと，$n$ と $r$ の最大公約数は，$m$ と $n$ の最大公約数と同じ値になります．よって，`gcd` 自身を再帰的に呼び出し，`gcd(n, m % n)` を返り値としています．

再帰的な呼出しを繰り返すたびに `n` が小さくなっていくので，`n` はいつか $0$ になって再帰が終了します．

# スタック
前の章で，変数の値はメモリ上のどこかに保存されると言いました．それを踏まえて，上で登場した関数 `digit_sum` をもう一度見てみましょう．
```rust
fn digit_sum(n: i32) -> i32 {
    if n == 0 {
        return 0;
    }
    let last_digit = n % 10;
    let higher_digits_sum = digit_sum(n / 10);
    let result = higher_digits_sum + last_digit;
    println!(
        "{} の各桁の和は {} + {} = {}",
        n, higher_digits_sum, last_digit, result
    );
    result
}
```

`digit_sum(6318)` を呼び出して $6318$ の各桁の和を計算する過程全体を通して，変数 `last_digit`，`higher_digits_sum`，`result` の値を保存するために必要なメモリは，それぞれ `i32` × 1 個分ずつでしょうか．

答えは「いいえ」です．

まず，`digit_sum(6318)` の中で `last_digit` に $8$ が代入されます．この `last_digit` を①とおきます．続いて，再帰的に呼び出される `digit_sum(631)` の中では同名の `last_digit` に別の値 $1$ が代入されます．こちらの `last_digit` を②とおきます．

`digit_sum(6318)` において，①に $8$ を代入し，続いて `digit_sum(631)` を呼び出し，それが終わったあと①に代入した値 $8$ を使用しています．このとき `digit_sum(631)` 中で②に $1$ を代入して使用するので，その間に①の値 $8$ が失われてしまわないよう，`digit_sum(631)` で①の `i32` × 1 個分とは別に②のためのメモリをさらに `i32` × 1 個分消費する必要があります．

`digit_sum(631)` の処理が終了すれば，②のためのメモリ `i32` × 1 個分は必要なくなり，空いた部分は別の変数のために再び使えるようになります．

同様に， `digit_sum(63)` でさらに `i32` × 1 個分， `digit_sum(6)` でさらに `i32` × 1 個分と，再帰呼出しのたびに使用中のメモリは増えてゆきます．一方， `digit_sum(6)` が終了すれば `i32` × 1 個分が必要なくなり， `digit_sum(63)` が終了すればさらに `i32` × 1 個分が必要なくなるといったように，関数が終了するたびにメモリが空いて再び使えるようになります．

引数 `n` についても，代入が関数内でなく呼出し元で行われることを除けば，同様です． `digit_sum(6318)` が呼び出された段階では `n` の値 $6318$ を保存するために `i32` × 1 個分が消費されていますが， `digit_sum(631)` の再帰呼出しで値 $631$ を保存するためにさらに `i32` × 1 個分， `digit_sum(63)` の再帰呼出しで値 $63$ を保存するためにさらに `i32` × 1 個分と， `n` のために消費されるメモリも増えてゆきます．これも，関数が終了するたびに空いて再び使えるようになります．

このように，関数の中で変数の値を保存するのに必要なメモリの量は，関数が呼び出されると増え，関数が終了すると呼出し前の量まで減ります．このとき，メモリを管理するために**スタック**という仕組みが利用されます．以下の図のようにアドレス空間を端の方から使い，関数中の変数や引数，そのほか関数が終了したあと呼出し元の状態に戻すのに必要な情報などを書き込みます．この領域をスタックといいます．スタックは，矢印の方向に伸びてゆきます．
![](/images/stack.png)

関数呼出しの際は，スタックの端を必要なだけ伸ばします．この領域は，関数が終了すると再び使えるようになります．
![](/images/stack_function_call.png)

ここでは再帰関数を例に挙げてスタックについて説明しましたが，再帰関数が特別というわけではなく，普通の関数呼出しでもスタックが使われています．

## 静的領域
第 14 章の最後で登場した，静的なライフタイムをもつデータは，**静的領域**と呼ばれる領域に置かれます．必要なメモリ量が実行中に増えたり減ったりしないので，プログラム開始からプログラム終了まで決まった場所に置かれます．

## スタックが使えない場合
今まで，1 つの変数が使用するメモリの量が途中で変化することはありませんでした．たとえば `i32` 型であれば最初から最後まで 4 バイトのまま，`[f64; 2]` 型であれば最初から最後まで 16 バイトのままで，大きさが変化しません．一方，[第 24 章](https://zenn.dev/toga/books/rust-atcoder/viewer/vector)では，必要なメモリの量が途中で変化するような型が登場します．このような変数が保持するデータは，スタックを用いて管理できないので，ヒープと呼ばれる別の領域を用いることになります．

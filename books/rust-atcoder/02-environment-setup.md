---
title: "環境構築"
---

# 環境構築
前章で，コードテストを用いて AtCoder のサーバ上でコンパイルと実行を行う方法を説明しました．しかし，提出しないときは自分のパソコン上でコンパイルと実行を行いたい人もいるでしょう．この章では，そのような人のために環境構築の仕方を説明します．

これからもコードテストを使い続ける人は，この章を読み飛ばしてもかまいません．

# CLI
Rust を使う上で CLI （ CUI ）を扱う必要があるため， CLI について説明します．慣れている人は[ここ](#インストールするもの)まで読み飛ばしてかまいません．

コマンドは，次のような場所で実行できます．
- コマンドプロンプト（Windows）
- PowerShell （Windows）
- ターミナル（MacOS）
- 端末（Ubuntu）
- VSCode 上のターミナル（Windows / MacOS / Linux）
- その他の端末エミュレータ
- デフォルトの CLI 環境（Linux．WSL 含む）

自分の環境に存在するものをどれか 1 つ開いてください．すると，**シェル**というものが起動し，キーボードからの入力を受け付けるようになるはずです．

手始めに，次のコマンドを実行してみましょう（ただし， Windows のコマンドプロンプトを使っている場合は `pwd` が存在しないので `cd` で置き換えてください）．
```
$ pwd
```
先頭の `$` はシェルがコマンド入力を受け付けているというサインで，あなたが実際に入力するのは `pwd` だけです．環境によっては `$` ではなく `>` だったり `%` だったりするかもしれません．ただしこれが `#` のときは root としてシェルを開いている可能性が高いので注意してください．

入力したらエンターキーを押して実行してください． Windows なら `C:` や `D:` ， MacOS や Linux なら `/` から始まるパスが出力されるはずです．これは**カレントディレクトリ**というものを表しています．

コンピュータの中にはデータの階層構造が形成されていて，たとえば Pictures というディレクトリ（フォルダともいいます）の中に写真が入っていたり， Downloads というディレクトリの中にダウンロードしたファイルが入っていたりします．シェルを使うとき，あなたは常に，何らかのディレクトリを基点として，その中や外にあるファイルを操作することになります．今操作の基点となっているディレクトリのことを，カレントディレクトリといいます．

`cd` コマンドを使うと，カレントディレクトリを移動することができます．カレントディレクトリ直下に `Documents` というディレクトリがあるとき，
```
$ cd Documents
```
を実行するとカレントディレクトリが `Documents` に移動します．

`ls` コマンドを使うと，カレントディレクトリ直下にあるファイルの一覧を得ることができます（ただし， Windows のコマンドプロンプトでは `ls` が存在しないので代わりに `dir` を使います）．
```
$ ls
```

前章で説明したプログラムと同じように，これらのコマンドも標準出力，標準エラー出力を用いています． `pwd` や `ls` によって出力されるのは標準出力です．一方， `cd` で存在しないディレクトリに移動しようとしたときは，標準エラー出力にその旨が出力されます．また，これらの他には実行すると標準入力を受け付けるコマンドもあります．このように，コマンドを入力して実行し，標準入力・標準出力・標準エラー出力を用いてプログラムとやり取りする環境のことを，**コマンドラインインターフェース（CLI）** 環境といいます．
# インストールするもの
まず，Rust を書いて実行できる環境を構築するためにインストールするものを挙げておきます．
## `rustc`（`rustup` が自動でインストール）
Rust のコンパイラです． Rust で書かれたソースコードをコンパイルし，実行可能ファイルを生成します．
## `cargo`（`rustup` が自動でインストール）
コンパイルとその周辺の処理を合わせて**ビルド**といいます．周辺の処理というのは，たとえばプログラムの部品となる便利な道具（**ライブラリ**といいます）を必要に応じて揃えたり，プログラムが正常に動作するかテストしたりすることです． `cargo` は， Rust のビルドを自動化するツールです．この章では， `rustc` を直接実行する代わりに， `cargo` を通して `rustc` を間接的に実行する方法を説明します．

Web や暗号や GUI など，用途ごとに様々なライブラリが存在します．たとえば複雑な計算をする部分を専用のライブラリに任せたり，インターネット上のデータにアクセスする部分だけを専用のライブラリに任せたりすると，大規模なプログラムを書くのが簡単になります．このようにライブラリを部品のように組み合わせてプログラムを書くとき， 1 つ 1 つの部品のことを Rust では**クレート**といいます．あなたが直接書いた部分も 1 つのクレートとして数えます．

[crates.io](https://crates.io) では Rust の様々なライブラリクレートが公開されており，使いたいものを `Cargo.toml` というファイルに書き込んでおくと， `cargo` がダウンロードとビルドを自動的に行ってくれます．これは[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/07-input)で使います．
## `rustup`
`rustc` や `cargo`，その他周辺のツールを合わせて **Rust ツールチェーン**といいます． `rustup` は， Rust ツールチェーンのインストールとバージョン管理を行うツールです． `rustup` をインストールすると， `rustc` と `cargo` も自動的にインストールされます．
## RLS
Windows の「メモ帳」や MacOS の「テキストエディタ」といった OS の標準テキストエディタを使用しても，ソースコードを読み書きすることは可能です．しかし，高機能なエディタを使うとより快適にプログラミングをすることができます．

Rust Language Server（RLS）は，エディタに Rust 用の機能（補完やエラー表示）を提供するツールです． VSCode や Vim や Emacs を始めとする様々なエディタで RLS を利用することができます．この章では，エディタとして VSCode を使う場合について説明します．

RLS も Rust ツールチェーンの 1 つであり，`rustup` を通してインストールします．`rustc` や `cargo` と違い，`rustup` をインストールしただけで RLS が自動的にインストールされるわけではありません．ただし，VSCode を使っている場合は，VSCode が自動的に `rustup` を呼び出して RLS をインストールしてくれます．
# 手順
## `rustup` のインストール
[公式ページ](https://www.rust-lang.org/ja/tools/install)を開き，書かれた手順に従ってください．

MacOS や Linux の場合は，表示されているコマンドを一度実行するだけです．万が一 `ld` のようなリンカがインストールされていない場合，これもインストールする必要があります．

一方 Windows の場合は， `rustup` 自体のインストーラの実行にくわえて，Visual C++ Build Tools のインストールが必要になります．[Microsoft による解説](https://docs.microsoft.com/ja-jp/windows/dev-environment/rust/setup)もあります．
## `rustup` `rustc` `cargo` がインストールされていることの確認
次のコマンドを実行してバージョンが表示されれば，正常にインストールされています．
```
$ rustup --version
$ rustc --version
$ cargo --version
```
`--` はハイフン 2 個です．
## `cargo` によるビルド
`cargo` は， `new` や `build` や `run` などのサブコマンドをとります．

まず， Hello, world! の出力から始めましょう．新たなパッケージを作成するにはサブコマンド `new` を使います．次を実行してください．
```
$ cargo new hello_world
```
すると，カレントディレクトリ直下に `hello_world` という名前のディレクトリが作られ，そこに Rust のコードを書く環境が整います． `cd` で今できたディレクトリに移動してください．
```
$ cd hello_world
```
このディレクトリの中にある `src/main.rs` にソースコードを書いていきます．このとき，標準出力に `Hello, world!` とだけ出力する次のようなプログラムが初めから書かれています．
```rust:src/main.rs
fn main() {
    println!("Hello, world!");
}
```
サブコマンド `run` で，ビルドと実行を行うことができます．
```
$ cargo run
```
`Hello, world!` と出力されれば成功です．

実行せずにビルドだけ行いときは，サブコマンド `build` を使います．
```
$ cargo build
```

ソースコードに文法的な間違いがあると，コンパイルの際にエラーが起きます．サブコマンド `check` を使うと，ソースコードの文法に間違いがないかチェックすることができます．実際にビルドを行わない分， `cargo build` より速いです．
```
$ cargo check
```

また， `hello_world` 直下に `Cargo.toml` というファイルも作られているはずです．これを開くと， `[dependencies]` と書かれた行があるでしょう．ライブラリクレートを使用したいときはこの下にその旨を記述します．記述の仕方については[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/07-input)で説明します．

##  RLS のインストール
エディタとして VSCode を使う場合を想定します．

まず， VSCode を開いた状態で Ctrl + Shift + P を押し，
```
ext install rust-lang.rust
```
を入力して実行することで， [Rust 用の拡張機能](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust)がインストールされます．すると， `cargo new` で作ったディレクトリ（上の例ならば `hello_world`）を VSCode で開いたときに，コードの補完やエラーの表示が有効になります．
# ジャッジシステムとバージョンを合わせる方法
Rust は，日々少しずつ変化する言語です．[GitHub](https://github.com/rust-lang/) 上で毎日多くの人が議論を重ね，よりよい言語にしようとしています．新しい Rust ツールチェーンが公開されたら， `rustup` を使って自分の環境をアップデートすることができます．

古い `rustc` でコンパイルできたソースコードが新しい `rustc` でコンパイルできなくなることはありません．これを**後方互換性**といいます．一方，新しい `rustc` でコンパイルできるソースコードが古い `rustc` でコンパイルできないことは十分に考えられます．

Rust で書いたコードを AtCoder に提出すると，ジャッジ（正誤判定）のためにビルドと実行が行われます．このときに用いられるのは，AtCoder のサーバーにインストールされている Rust ツールチェーンです．手元の Rust ツールチェーンと AtCoder の Rust ツールチェーンのバージョンが異なる場合，手元で動くコードが AtCoder 上では動かないといった問題が生じるかもしれません．

Rust のバージョンは， 1.42.0 のように 3 つの数字の組として表されます．

手元の Rust ツールチェーンのバージョンは，次のコマンドで確認することができます．
```
$ rustc --version
```
`rustc 1.42.0 (b8cedc004 2020-03-09)` のような出力であれば， `1.42.0` がバージョンです．

一方， AtCoder の Rust ツールチェーンのバージョンは，コード提出画面の言語選択欄に書かれています．言語リストから Rust を選択するときに「 Rust (X.XX.X) 」のように書かれていたら， X.XX.X がバージョンです（2020 年言語アップデート後だと 1.42.0 です）．

手元の環境を AtCoder に合わせる場合，まず AtCoder と同じバージョンの Rust ツールチェーンをインストールする必要があります．インストーラである `rustup` を使うと次のコマンドでインストールできます．
```
$ rustup toolchain install X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

いま手元の環境には，もともとあった Rust ツールチェーンと今インストールした Rust ツールチェーンが両方存在しています．次のコマンドを実行することで，今インストールしたバージョン `X.XX.X` のツールチェーンが今後のビルドに用いられるようになります．
```
$ rustup default X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

再度バージョンの確認をして， AtCoder と同じものに変わっていることを確かめてください．
```
$ rustc --version
```

これで， AtCoder とのバージョンの差を気にすることなく Rust が書けるようになりました．
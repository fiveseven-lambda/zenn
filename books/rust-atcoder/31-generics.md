---
title: "ジェネリクス"
---

# ジェネリクス
`(f64, i32)` 型のタプルを受け取って， 2 つめの要素を返す， `second_f64_i32` 関数を考えます．
```rust
fn main() {
    assert_eq!(second_f64_i32((5., 3)), 3);
}

fn second_f64_i32((_, x): (f64, i32)) -> i32 { x }
```
引数をパターン `(_, x)` で受け取り， `x` を返しています．

同じように， `(f32, i32)` 型のタプルを受け取って 2 つめの要素を返す関数や， `(bool, i32)` 型のタプルを受け取って 2 つめの要素を返す関数なども作れます．
```rust
fn second_f64_i32((_, x): (f64, i32)) -> i32 { x }
fn second_f32_i32((_, x): (f32, i32)) -> i32 { x }
fn second_bool_i32((_, x): (bool, i32)) -> i32 { x }
```
このように同じ書き方ができるたくさんの関数は，**ジェネリクス**を使うと一度に書くことができます．

ジェネリクスを使った関数の定義は，次のようになります：
```rust
fn second_i32<T>((_, x): (T, i32)) -> i32 { x }
```
関数名 `second_i32` の後に `<T>` が付き， `f64` や `f32` や `bool` だった部分が `T` に置き換わっています．こうすると， `T` を `f64` とした関数 `second_i32::<f64>` ， `T` を `f32` とした関数 `second_i32::<f32>` ， `T` を `bool` とした関数 `second_i32::<bool>` などが*全ての型 `T` について*一斉に使えるようになります．
```rust
fn main() {
    assert_eq!(second_i32::<f64>((3_f64, 5)), 5);
    assert_eq!(second_i32::<f32>((3_f32, 5)), 5);
    assert_eq!(second_i32::<bool>((true, 5)), 5);
}
```

この `T` を**型パラメータ**といいます．ジェネリクスを使って定義された関数 `second_i32` を呼び出すときは，引数だけでなく型パラメータも渡す必要があるわけです．

また，型パラメータの個数を増やすこともできます． `<T>` の代わりに `<T, U>` を付ければ，今まで `i32` としていた 2 つめの要素の型も任意の型に変えることができます．
```rust
fn second<T, U>((_, x): (T, U)) -> U { x }
```
たとえば `second::<f64, char>` は「 `(f64, char)` 型のタプルを受け取って 2 つめの要素を返す関数」となります．

:::message
`T` や `U` といった型パラメータの名前のルールは，[変数名のルール](https://zenn.dev/toga/books/rust-atcoder/viewer/05-variable#%E5%A4%89%E6%95%B0%E5%90%8D%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%AB)と同じです．しかし，名付け方の慣例は変数や関数と違い，ふつう大文字 1 文字とします． 2 文字以上の場合は[キャメルケース](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%A1%E3%83%AB%E3%82%B1%E3%83%BC%E3%82%B9)（ `ElementType` のように大文字と小文字で単語の区切りを表現するやり方）を用います．
:::
## 型推論
上で定義した `second` 関数を使うとき，型パラメータを与える代わりに `_` と書くと，型を推論させることができます．
```rust
let result = second::<bool, _>((true, 65));
assert_eq!(result, b'A');
```
今回， 1 つめの型パラメータ `T` には `bool` を与えましたが， 2 つめの型パラメータ `U` は `_` として型推論に任せています．ここで， `second` 関数の返り値の値が `U` であることから，変数 `result` の型が `U` と同じになるということが分かります． `result` はそのあと `u8` 型のリテラル `b'A'` と比較されているので， `U` は `u8` となります．そして整数リテラル `65` も `u8` 型に推論されます．

また， `true` の型が `bool` なので `T` も型推論に任せることができます．
```rust
let result = second::<_, _>((true, 65));
assert_eq!(result, b'A');
```
このように全ての型パラメータが推論できる状況では， `::<_, _>` を付ける必要が無くなり，普通の関数を呼び出すときと全く同じ書き方ができるようになります．
```rust
let result = second((true, 65));
assert_eq!(result, b'A');
```
:::message
文字 `A` の ASCII コードは 65 です．
:::
# トレイト
---
title: "環境構築"
---

# 環境構築
前章で，コードテストを用いて AtCoder のサーバ上でコンパイルと実行を行う方法を説明しました．しかし，提出以外の場面では自分のパソコン上でコンパイルと実行を行いたい人もいるでしょう．この章では，そのような人のために環境構築の仕方を説明します．

これからもコードテストを使い続ける人は，この章を読み飛ばしてもかまいません．

# CLI
Rust を使う上で CLI（CUI）を扱う必要があるため，その方法について説明します．慣れている人は[ここ](#インストールするもの)まで読み飛ばしてかまいません．

GUI 環境では，次のような場所で CLI と同じことができます．
- コマンドプロンプト（Windows）
- PowerShell （Windows）
- ターミナル（MacOS）
- 端末（Ubuntu）
- VSCode 上のターミナル（Windows / MacOS / Linux）
- その他の端末エミュレータ
- WSL 上の CLI 環境（Windows）

自分の環境に存在するものをどれか 1 つ開いてください．すると，**シェル**というものが起動し，キーボードからの入力を受け付けるようになるはずです．

手始めに，次のコマンドを実行してみましょう（ただし， Windows のコマンドプロンプトを使っている場合は `pwd` が存在しないので `cd` で置き換えてください）．
```
$ pwd
```
先頭の `$` はシェルがコマンド入力を受け付けているというサインで，あなたが実際に入力するのは `pwd` だけです．環境によっては `$` ではなく `>` だったり `%` だったりするかもしれません．

`pwd` と入力したら，エンターキーを押して実行してください． Windows なら `C:` や `D:`，MacOS や Linux なら `/` から始まる**パス**が出力されるはずです．これは**カレントディレクトリ**というものを表しています．

コンピュータの中にはデータの階層構造が形成されていて，たとえば Pictures というディレクトリ（フォルダともいいます）の中に写真が入っていたり，Downloads というディレクトリの中にダウンロードしたファイルが入っていたりします．日本の住所が都道府県名・市町村名・番地などを並べて表されるのと同じように，コンピュータ内におけるあるファイルの位置も `/home/user/Documents` のようにディレクトリ名を並べて表されます．この文字列をパスといいます．

シェルを使うとき，あなたは常に，何らかのディレクトリを基点として，その中や外にあるファイルを操作することになります．今操作の基点となっているディレクトリのことを，カレントディレクトリといいます．このカレントディレクトリを知るために使うコマンドが，今実行した `pwd` です．

`cd` コマンドを使うと，カレントディレクトリを移動することができます．カレントディレクトリ直下に `Documents` というディレクトリがあるとき，
```
$ cd Documents
```
を実行するとカレントディレクトリが `Documents` に移動します．

:::message
大抵のシェルには補完機能というものがあり，`Documents` という名前を全て入力しなくても，最初の数文字（例えば `Do`）まで入力して Tab キーを押すと `Documents` まで自動で補完されます（ただし `Documents` と `Downloads` のように名前の先頭が他と被っている場合は，最後まで補完されなかったり Tab を数回押す必要があったりします）．長い名前もミスなく入力できるため便利です．
:::

`ls` コマンドを使うと，カレントディレクトリ直下にあるファイルの一覧を得ることができます（ただし， Windows のコマンドプロンプトでは `ls` が存在しないので代わりに `dir` を使います）．
```
$ ls
```

前章で説明したプログラムと同じように，これらのコマンドも標準出力，標準エラー出力を用いています．`pwd` はカレントディレクトリのパスを，`ls` はディレクトリ内のファイル一覧を，それぞれ標準出力に対して出力します．一方， `cd` で存在しないディレクトリに移動しようとしたときは，標準エラー出力に存在しない旨が出力されます．また，これらの他には実行すると標準入力を受け付けるコマンドもあります．このように，コマンドを入力して実行し，標準入出力を用いてプログラムとやり取りする環境が，**コマンドラインインターフェース**（CLI）です．
# インストールするもの
Rust の環境を構築するためには，以下のものをインストールします．
## `rustc`（`rustup` が自動でインストール）
Rust のコンパイラです． Rust で書かれたソースコードをコンパイルし，実行可能ファイルを生成します．
## `cargo`（`rustup` が自動でインストール）
コンパイルとその周辺の処理を合わせて**ビルド**といいます．周辺の処理というのは，たとえばプログラムの部品となる便利な道具（**ライブラリ**といいます）を必要に応じて揃えたり，プログラムが正常に動作するかテストしたりすることです． `cargo` は， Rust のビルドを自動化するツールです．この章では， `rustc` を直接実行する代わりに， `cargo` を通して `rustc` を間接的に実行する方法を説明します．

Web や暗号や GUI など，用途ごとに様々なライブラリが存在します．たとえば複雑な計算をする部分を専用のライブラリに任せたり，インターネット上のデータにアクセスする部分だけを専用のライブラリに任せたりすると，大規模なプログラムを書くのが簡単になります．このようにライブラリを部品のように組み合わせてプログラムを書くとき， 1 つ 1 つの部品のことを Rust では**クレート**といいます．あなたが直接書いた部分も 1 つのクレートとして数えます．

[crates.io](https://crates.io) では Rust の様々なライブラリクレートが公開されており，使いたいものを `Cargo.toml` というファイルに書き込んでおくと， `cargo` がダウンロードとビルドを自動的に行ってくれます．これは[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/input)で使います．
## `rustup`
`rustc` や `cargo`，その他周辺のツールを合わせて **Rust ツールチェーン**といいます．`rustup` は， Rust ツールチェーンのインストールとバージョン管理を行うツールです．`rustup` を使うと，特定のバージョンの `rustc` をインストールしたり，複数のバージョンの `rustc` を使い分けたりすることができます．

`rustup` をインストールすると， `rustc` と `cargo` も自動的にインストールされます．
## RLS
ソースコードの中身はただの文字が並んだテキストファイルなので，Windows の「メモ帳」や MacOS の「テキストエディタ」といった OS の標準テキストエディタを使用しても読み書きが可能です．しかし，高機能なエディタを使うとより快適にプログラミングをすることができます．

Rust Language Server（RLS）は，エディタに Rust 用の機能（補完やエラー表示）を提供するツールです． VSCode や Vim や Emacs を始めとする様々なエディタで RLS を利用することができます．この章では，エディタとして VSCode を使う場合について説明します．

RLS も Rust ツールチェーンの 1 つであり，`rustup` を通してインストールします．`rustc` や `cargo` と違い，`rustup` をインストールしただけで RLS が自動的にインストールされるわけではありません．ただし，VSCode を使っている場合は，VSCode が自動的に `rustup` を呼び出して RLS をインストールしてくれます．
# 手順
## `rustup` のインストール
[公式ページ](https://www.rust-lang.org/ja/tools/install)を開き，書かれた手順に従ってください．

MacOS や Linux の場合は，表示されているコマンドを一度実行するだけです．

一方 Windows の場合は， `rustup` 自体のインストーラの実行にくわえて，Visual C++ Build Tools のインストールが必要になります．[Microsoft による解説](https://docs.microsoft.com/ja-jp/windows/dev-environment/rust/setup)もあります．
## `rustup` `rustc` `cargo` がインストールされていることの確認
次のコマンドを実行してバージョンが表示されれば，正常にインストールされています．
```
$ rustup --version
$ rustc --version
$ cargo --version
```
`--` はハイフン 2 個です．
## `cargo` によるビルド
さっそく，`cargo` を使ってみましょう．

`rustc` はソースコードをコンパイルするだけですが，`cargo` はこれにくわえてライブラリの準備など周辺の処理も行います．`cargo` は，1 つのプログラムを構成する情報（ソースコードの他に，必要なライブラリクレートのリストなど）を合わせて**パッケージ**という単位で扱います．新しいプログラムを作るときは，まずこのパッケージを作ることになります．

以下のコマンドを実行してください．すると，カレントディレクトリの直下に `hello_world` という名前のディレクトリが新しく作られ，その中身が 1 つのパッケージとなります．
```
$ cargo new hello_world
```
`cargo` の後に続く `new` が，新しいパッケージの作成を意味します．

`cd` コマンドを使って今できたディレクトリ `hello_world` に移動してください．
```
$ cd hello_world
```
ここで，`ls` コマンドを使ってこのディレクトリ内に何があるか見てみましょう．
```
$ ls
```
`hello_world` 内には今，`src` という名前のディレクトリと，`Cargo.toml` という名前のファイルがあるはずです．先ほど述べたパッケージの構成要素のうち，ソースコードは `src` 内のファイルに，その他の情報は `Cargo.toml` に書きこむことになります．

さらに，`src` ディレクトリの中身も覗いてみましょう．`ls` とだけ打つとカレントディレクトリ直下のファイル一覧が得られますが，`ls` に続けてディレクトリ名 `src` を打つと，`src` 直下のファイル一覧が得られます．
```
$ ls src
```
`src` 内には `main.rs` という名前のファイルがあるはずです．これがソースコードを書きこむファイルです．ファイル名末尾の `.rs` は，Rust のソースコードであることを意味する拡張子です．

`main.rs` の中身は，はじめ次のようになっています．
```rust:src/main.rs
fn main() {
    println!("Hello, world!");
}
```
これは，標準出力に `Hello, world!` と出力するプログラムのソースコードです．

さて，このままの状態でビルドを行ってみましょう．次のコマンドを実行してください．
```
$ cargo build
```
ビルドが行われました．`ls` コマンドを再び打って，`hello_world` ディレクトリ内にあるものを表示してみましょう．
```
$ ls
```
`src` と `Cargo.toml` にくわえて，`target` という名前のディレクトリが新しくできているはずです．これは，`cargo` がビルドの成果物を置く場所です．成果物の中には実行ファイルも含まれており，呼び出して実行することができます．
```
$ target/debug/hello_world
```
`Hello, world!` と出力されれば，成功です．

`cargo build` と `target/debug/hello_world` の代わりに `cargo run` を打つと，ビルドと実行がいっぺんに行われます．
```
$ cargo run
```

ソースコードに文法的な間違いがあると，コンパイルの際にエラーが起きます．サブコマンド `check` を使うと，ソースコードの文法に間違いがないかチェックすることができます．実際にビルドを行わない分， `cargo build` より速いです．
```
$ cargo check
```

## `Cargo.toml`
`Cargo.toml` には，`cargo` が必要とする情報が含まれているといいました．実際に `Cargo.toml` を開いて中身を見てみると， `[dependencies]` と書かれた行があるでしょう．ライブラリクレートを利用したいときは，この下にその旨を記述します．記述の仕方については[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/input)で説明します．

##  RLS のインストール
エディタとして VSCode を使う場合を想定します．

まず， VSCode を開いた状態で Ctrl + p を押し，
```
ext install rust-lang.rust-analyzer
```
を入力して実行することで， [Rust 用の拡張機能](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)がインストールされます．すると，Rust のパッケージのあるディレクトリを VSCode で開いたときに，コードの補完やエラーの表示が有効になります．
# ジャッジシステムとバージョンを合わせる方法
Rust は，日々少しずつ変化する言語です．[GitHub](https://github.com/rust-lang/) 上で毎日多くの人が議論を重ね，よりよい言語にしようとしています．新しい Rust ツールチェーンが公開されたら， `rustup` を使って自分の環境をアップデートすることができます．

古い `rustc` でコンパイルできたソースコードが新しい `rustc` でコンパイルできなくなることはありません．これを**後方互換性**といいます．一方，新しい機能を使って書かれたソースコードが新しい `rustc` でコンパイルできても古い `rustc` でコンパイルできないことは十分に考えられます．

Rust で書いたコードを AtCoder に提出すると，ジャッジ（正誤判定）のためにビルドと実行が行われます．このときに用いられるのは，AtCoder のサーバーにインストールされている Rust ツールチェーンです．手元の Rust ツールチェーンと AtCoder の Rust ツールチェーンのバージョンが異なる場合，手元で動くコードが AtCoder 上では動かないといった問題が生じるかもしれません．

Rust のバージョンは， 1.42.0 のように 3 つの数字の組として表されます．

手元の Rust ツールチェーンのバージョンは，次のコマンドで確認することができます．
```
$ rustc --version
```
`rustc 1.42.0 (b8cedc004 2020-03-09)` のような出力であれば， `1.42.0` がバージョンです．

一方， AtCoder の Rust ツールチェーンのバージョンは，コード提出画面の言語選択欄に書かれています．言語リストから Rust を選択するときに「 Rust (X.XX.X) 」のように書かれていたら， X.XX.X がバージョンです．2020 年言語アップデート後だと 1.42.0 で，2023 年言語アップデート後に 1.66.1 となる予定です．

手元の環境を AtCoder に合わせる場合，まず AtCoder と同じバージョンの Rust ツールチェーンをインストールする必要があります．インストーラである `rustup` を使うと次のコマンドでインストールできます．
```
$ rustup toolchain install X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

いま手元の環境には，もともとあった Rust ツールチェーンと今インストールした Rust ツールチェーンが両方存在しています．次のコマンドを実行することで，今インストールしたバージョン `X.XX.X` のツールチェーンが今後のビルドに用いられるようになります．
```
$ rustup default X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

再度バージョンの確認をして， AtCoder と同じものに変わっていることを確かめてください．
```
$ rustc --version
```

これで， AtCoder とのバージョンの差を気にすることなく Rust が書けるようになりました．
---
title: "環境構築"
---

# 環境構築
AtCoder のコンピュータ（サーバ）上には Rust のコンパイラがあり，インターネットを伝って AtCoder に提出された Rust のソースコードをコンパイルしています．あなたが今手元に持っているパソコンの中にも Rust のコンパイラを入れれば，インターネットを経由することなく手元で Rust のソースコードをコンパイルできるようになります．これには以下のようなメリットがあります．
- 自分の書いたプログラムに誤り（バグ）があるとき，原因をより詳細に分析できます．
- 競技プログラミングに便利なツールを導入できます．
  例：https://kato-hiro.github.io/AtCoderClans/cli/test_tools/#rust
- 競技プログラミング以外の用途（業務，研究，趣味）にも Rust を利用できます．

この章では，あなたのパソコン上で Rust のコンパイラが動くようにする方法を説明します．もしその必要が無ければ，この章は読み飛ばしてもかまいません．

# CLI
Rust を使う上で，前の章で説明した CLI (CUI) を扱う必要があるため，その方法について説明します．既に CLI に慣れている人は[ここ](#インストールするもの)まで読み飛ばしてかまいません．

今の時代，多くの人がパソコンとして持っているコンピュータは CLI ではなく GUI だと思います．しかし，GUI 環境でも次のような場所で CLI と同じことができます．
- コマンドプロンプト (Windows)
- PowerShell (Windows)
- ターミナル (MacOS)
- 端末 (Ubuntu)
- VSCode 上のターミナル (Windows, MacOS, Linux)
- その他の端末エミュレータ
- WSL 上の CLI 環境 (Windows)

自分の環境に存在するものをどれか 1 つ開いてください．すると，**シェル**というものが起動し，キーボードからの入力を受け付けるようになるはずです．ここから先は CLI なので，コンピュータへの指示は全てキーボードを通して行います．

手始めに，次のコマンドを実行してみましょう（ただし， Windows のコマンドプロンプトを使っている場合は `pwd` が存在しないので，以下 `pwd` を全て `cd` で置き換えてください）．
```
$ pwd
```
先頭の `$` はシェルがコマンド入力を受け付けているというサインで，あなたが実際に入力するのは `pwd` だけです．環境によっては `$` ではなく `>` だったり `%` だったりするかもしれません．

`pwd` と入力したら，Enter キー（Return キー）を押して実行してください． Windows なら `C:` や `D:`，MacOS や Linux なら `/` から始まる**パス**が出力されるはずです．これは**カレントディレクトリ**というものを表しています．

コンピュータの中にはデータの階層構造が形成されていて，たとえば Pictures という名前のディレクトリ（フォルダともいいます）の中に写真が入っていたり，Downloads という名前のディレクトリの中にダウンロードしたファイルが入っていたりします．日本の住所が都道府県名・市町村名・番地などを並べて表されるのと同じように，コンピュータ内におけるあるファイルの位置も，例えば `home` の中の `user` の中の `Documents` であれば `/home/user/Documents` といったように，ディレクトリ名を並べて表されます．この文字列をパスといいます．

シェルを使うとき，あなたは常に，何らかのディレクトリを基点として，その中や外にあるファイルを操作することになります．今操作の基点となっているディレクトリのことを，カレントディレクトリといいます．このカレントディレクトリを知るために使うコマンドが，今実行した `pwd` です．

`cd` コマンドを使うと，カレントディレクトリを移動することができます．カレントディレクトリ直下に `Documents` というディレクトリがあるとき，
```
$ cd Documents
```
を実行するとカレントディレクトリが `Documents` に移動します．

:::message
大抵のシェルには補完機能というものがあり，`Documents` という名前を全て入力しなくても，最初の数文字（例えば `Do`）まで入力して Tab キーを押すと `Documents` まで自動で補完されます（ただし `Documents` と `Downloads` のように名前の先頭が他と被っている場合は，最後まで補完されなかったり Tab を数回押す必要があったりします）．長い名前もミスなく入力できるため便利です．
:::

`ls` コマンドを使うと，カレントディレクトリ直下にあるファイルの一覧を得ることができます（ただし， Windows のコマンドプロンプトでは `ls` が存在しないので代わりに `dir` を使います）．
```
$ ls
```

前章で説明したプログラムと同じように，これらのコマンドも標準出力，標準エラー出力を用いています．`pwd` はカレントディレクトリのパスを，`ls` はディレクトリ内のファイル一覧を，それぞれ標準出力に対して出力します．一方， `cd` で存在しないディレクトリに移動しようとしたときは，標準エラー出力に存在しない旨が出力されます．また，これらの他には実行すると標準入力を受け付けるコマンドもあります．このように，コマンドを入力して実行し，標準入出力を用いてプログラムとやり取りする環境が，**コマンドラインインターフェース**（CLI）です．
# インストールするもの
Rust の環境を構築するためには，以下のものをインストールします．
## `rustc`（`rustup` が自動でインストール）
`rustc` は Rust のコンパイラです．Rust で書かれたソースコードをコンパイルし，実行可能ファイルを生成します．
## `cargo`（`rustup` が自動でインストール）
コンパイルとその周辺の処理を合わせて**ビルド**といいます．周辺の処理というのは，たとえばプログラムの部品となる便利な道具（**ライブラリ**といいます）を必要に応じて揃えたり，プログラムが正常に動作するかテストしたりすることです． `cargo` は， Rust のビルドを自動化するツールです．この章では， `rustc` を直接実行する代わりに， `cargo` を通して `rustc` を間接的に実行する方法を説明します．

Web や暗号や GUI など，用途ごとに様々なライブラリが存在します．たとえば複雑な計算をする部分を専用のライブラリに任せたり，インターネット上のデータにアクセスする部分だけを専用のライブラリに任せたりすると，大規模なプログラムを書くのが簡単になります．このようにライブラリを部品のように組み合わせてプログラムを書くとき， 1 つ 1 つの部品のことを Rust では**クレート**といいます．あなたが直接書いた部分も 1 つのクレートとして数えます．

[crates.io](https://crates.io) では Rust の様々なライブラリクレートが公開されており，使いたいものを `Cargo.toml` というファイルに書き込んでおくと， `cargo` がダウンロードとビルドを自動的に行ってくれます．これは[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/input)で使います．
## `rustup`
Rust は，日々少しずつ変化する言語です．[GitHub](https://github.com/rust-lang/) という Web サイト上で毎日多くの人が議論を重ね，協力してよりよい言語にしようとしています．ここで，異なる時点における Rust を区別するために，3 つの数をピリオド `.` でつないだ**バージョン**が用いられています．バージョン「1.0.0」の Rust は 2015 年に公開され，それから Rust が新しくなるたびに 1.1.0，1.2.0，…とだんだん数が大きくなっています．

古いバージョンの `rustc` でコンパイルできたソースコードが新しいバージョンの `rustc` でコンパイルできなくなることは，基本的にありません．これを**後方互換性**といいます．一方，あるバージョンの Rust で新たに追加された機能を使って書かれたソースコードが，古いバージョンの `rustc` でコンパイルできないといった話はよくあります．

`rustc` や `cargo`，その他周辺のツールを合わせて **Rust ツールチェーン**といいます．`rustup` は， Rust ツールチェーンのインストールとバージョン管理を行うツールです．新しい Rust ツールチェーンが公開されたら，`rustup` を使って自分の環境をアップデートすることができます．わざと古いバージョンの `rustc` をインストールしたり，複数のバージョンの `rustc` を使い分けたりすることもできます．

初めに `rustup` をインストールすると， `rustc` と `cargo` も自動的にインストールされます．
# 手順
## `rustup` のインストール
[公式ページ](https://www.rust-lang.org/ja/tools/install)を開き，書かれた手順に従ってください．

MacOS や Linux の場合は，表示されているコマンドを CLI で一度実行するだけです．

一方 Windows の場合は， `rustup` 自体のインストーラの実行にくわえて，Visual C++ Build Tools のインストールも必要になります．[Microsoft による解説](https://docs.microsoft.com/ja-jp/windows/dev-environment/rust/setup)もあります．
## `rustup` `rustc` `cargo` がインストールされていることの確認
次のコマンドを実行してバージョンが表示されれば，正常にインストールされています．
```
$ rustup --version
$ rustc --version
$ cargo --version
```
`--` はハイフン 2 個です．
## `cargo` によるビルド
さっそく，`cargo` を使ってみましょう．

`rustc` はソースコードをコンパイルするだけですが，`cargo` はこれにくわえてライブラリの準備など周辺の処理も行います．`cargo` は，1 つのプログラムを構成する情報（ソースコードの他に，必要なライブラリクレートの一覧など）を合わせて**パッケージ**という単位で扱います．新しいプログラムを作るときは，まずこのパッケージを作ることになります．

以下のコマンドを実行してください．すると，カレントディレクトリの直下に `hello_world` という名前のディレクトリが新しく作られ，その中身が 1 つのパッケージとなります．
```
$ cargo new hello_world
```
`cargo` の後に続く `new` が，新しいパッケージの作成を意味します．

`cd` コマンドを使って，今できたディレクトリ `hello_world` に移動してください．
``` つ
$ cd hello_world
```
ここで，`ls` コマンドを使ってこのディレクトリ内に何があるか見てみましょう．
```
$ ls
```
`hello_world` 内には今，`src` という名前のディレクトリと，`Cargo.toml` という名前のファイルがあるはずです．先ほど述べたパッケージの構成要素のうち，ソースコードは `src` 内のファイルに，その他の情報は `Cargo.toml` に書きこむことになります．

さらに，`src` ディレクトリの中身も覗いてみましょう．`ls` とだけ打つとカレントディレクトリ直下のファイル一覧が得られますが，`ls` に続けてディレクトリ名 `src` を打つと，`src` 直下のファイル一覧が得られます．
```
$ ls src
```
`src` 内には `main.rs` という名前のファイルがあるはずです．これがソースコードを書きこむファイルです．ファイル名末尾の `.rs` は，Rust のソースコードであることを意味する拡張子です．

`main.rs` の中身は，はじめ次のようになっています．
```rust:src/main.rs
fn main() {
    println!("Hello, world!");
}
```
これは，標準出力に `Hello, world!` と出力するプログラムのソースコードです．

さて，このままの状態でビルドを行ってみましょう．次のコマンドを実行してください．
```
$ cargo build
```
ビルドが行われました．`ls` コマンドを再び打って，`hello_world` ディレクトリ内にあるものを表示してみましょう．
```
$ ls
```
`src` と `Cargo.toml` にくわえて，`target` という名前のディレクトリが新しくできているはずです．これは，`cargo` がビルドの成果物を置く場所です．成果物の中には実行ファイルも含まれており，呼び出して実行することができます．
```
$ target/debug/hello_world
```
`Hello, world!` と出力されれば，成功です．

`cargo build` と `target/debug/hello_world` の代わりに `cargo run` を打つと，ビルドと実行がいっぺんに行われます．
```
$ cargo run
```

ソースコードに文法的な間違いがあると，コンパイルの際にエラーが起きます．サブコマンド `check` を使うと，ソースコードの文法に間違いがないかチェックすることができます．実際にビルドを行わない分， `cargo build` より速いです．
```
$ cargo check
```

## `Cargo.toml`
`Cargo.toml` には，`cargo` が必要とする情報が含まれているといいました．実際に `Cargo.toml` を開いて中身を見てみると， `[dependencies]` と書かれた行があるでしょう．ライブラリクレートを利用したいときは，この下にその旨を記述します．記述の仕方については[第 7 章](https://zenn.dev/toga/books/rust-atcoder/viewer/input)で説明します．

# エディタ
ソースコードの中身はただの文字が並んだテキストファイルなので，Windows の「メモ帳」や MacOS の「テキストエディタ」といった OS の標準テキストエディタを使用しても読み書きが可能です．しかし，高機能なエディタを使うとより快適にプログラミングをすることができます．

VSCode や Vim や Emacs などのエディタは，プラグイン／拡張機能によって機能を増やすことができます．Rust 用のプラグイン／拡張機能も存在するので，これを入れれば Rust に特化した機能を持たせることができます．この章では，エディタとして VSCode を使う場合について説明します．
## rust-analyzer のインストール
エディタとして VSCode を使う場合，拡張機能 rust-analyzer を入れることで Rust 向けの様々な機能が手に入ります．たとえば，単語を途中まで入力したら残りを予測して候補を表示してくれる補完機能，エラーが生じているときにエラー箇所に下線を引いて強調してくれる機能などです．

まず， VSCode を開いた状態で Ctrl + p を押し，
```
ext install rust-lang.rust-analyzer
```
を入力して実行することで， [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)がインストールされます．すると，Rust のパッケージのあるディレクトリを VSCode で開いたときに，コードの補完やエラーの表示が有効になります．
# AtCoder とバージョンを合わせる方法
Rust で書いたコードを AtCoder に提出すると，ジャッジ（正誤判定）のためにビルドと実行が行われます．このときに用いられるのは，AtCoder のサーバーにインストールされている Rust ツールチェーンです．手元の Rust ツールチェーンと AtCoder の Rust ツールチェーンのバージョンが異なる場合，手元で動くコードが AtCoder 上では動かないといった問題が生じるかもしれません．

手元の Rust ツールチェーンのバージョンは，次のコマンドで確認することができます．
```
$ rustc --version
```
`rustc 1.42.0 (b8cedc004 2020-03-09)` のような出力であれば， `1.42.0` がバージョンです．

一方， AtCoder の Rust ツールチェーンのバージョンは，コード提出画面の言語選択欄に書かれています．言語リストから Rust を選択するときに「 Rust (rustc X.XX.X) 」のように書かれていたら， X.XX.X がバージョンです．2020 年言語アップデートから 2023 年言語アップデートまでは 1.42.0 で，2023 年言語アップデート後は 1.70.0 です．

手元の環境を AtCoder に合わせる場合，まず AtCoder と同じバージョンの Rust ツールチェーンをインストールする必要があります．インストーラである `rustup` を使うと次のコマンドでインストールできます．
```
$ rustup toolchain install X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

いま手元の環境には，もともとあった Rust ツールチェーンと今インストールした Rust ツールチェーンが両方存在しています．次のコマンドを実行することで，今インストールしたバージョン `X.XX.X` のツールチェーンが今後のビルドに用いられるようになります．
```
$ rustup default X.XX.X
```
`X.XX.X` の部分は， AtCoder の Rust ツールチェーンのバージョンで置き換えてください．

再度バージョンの確認をして， AtCoder と同じものに変わっていることを確かめてください．
```
$ rustc --version
```

これで， AtCoder とのバージョンの差を気にすることなく Rust が書けるようになりました．
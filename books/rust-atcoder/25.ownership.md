---
title: "所有権"
---

# ヒープ
[第 24 章](https://zenn.dev/toga/books/rust-atcoder/viewer/vector)で登場したベクタの要素は，配列と同様，メモリ上で連続した領域に置かれます．これにより，内部ではアドレスの足し算だけで $i$ 番目へのアクセスや `for` 文での走査ができます．

しかし， `push` 関数で要素の追加を繰り返すと，必要なメモリ量が増えてゆきます．そのため，[第 23 章](https://zenn.dev/toga/books/rust-atcoder/viewer/recursion#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF)で説明したスタックの仕組みだけだと，ベクタのためのメモリを管理できません．そこで，**ヒープ**という，メモリ上のスタックとは別の領域を使います．

ヒープを使用するプログラムは，実行しているあいだ常に，ヒープの中で未使用の部分を全て記録しています．ベクタのためのメモリが必要になったら，未使用の部分から一部とって使います．ベクタを使い終わったら，不要になった部分を未使用に戻します．このように，実行中にどこが未使用か記録しながらメモリを管理することを，**動的なメモリアロケーション**といいます．

スタックは，端の場所さえ記録しておけば，次の関数呼び出しで使える領域がすぐ分かります．これに比べて，ヒープにおける動的なメモリアロケーションはより複雑な仕組みを必要とします．しかしそのおかげで，前もって必要なメモリ量を知ることができなくても，実行中必要になったぶんのメモリを得ることができます．

動的なメモリアロケーションは，ベクタではなく，**アロケータ**という裏方が担います．今後ベクタ以外にもヒープを使用するものが登場しますが，皆メモリが必要になるとアロケータを通してメモリを得ます．

以下の図を用いて，ベクタとアロケータのやり取りを説明します．アロケータは，ヒープのどこが未使用か覚えています．
![](/images/heap-allocator.png)

ベクタはメモリが必要になるとアロケータに頼んで，使っていい場所（アドレス）を教えてもらいます．これを**アロケート**といいます．
![](/images/heap-allocate.png)

一方，メモリを使い終わって不要になると，アロケータにそのアドレスを伝えます．これを**デアロケート**といいます．アロケータは，デアロケートされた領域をそれ以降別のアロケートに使えます．
![](/images/heap-deallocate.png)

また，アロケートした後に大きさが足りなくなったら，アロケータにもっと広い空き領域を探してもらいます．これを**リアロケート**といいます．

:::message
実際は，これにくわえて OS によるメモリ管理が関わってきます．
:::

## デアロケート後の注意
アロケータを利用する際に，ベクタなどが注意しなくてはいけないことがあります．それは，メモリをデアロケートした後の取り扱いです．

既にデアロケートした領域は，アロケータが別のアロケートに使ってしまっている可能性があります．よって，デアロケート済みの領域にアクセスしたり，再びデアロケートを試みたりしてはいけません．

しかし，プログラマがベクタを使うたびにこれをいちいち気を付けなければいけないのだとしたら大変です．代わりに，以下で説明する**所有権**のルールが，不正なメモリアクセスをコンパイル時に検出します．

# 所有権
まず，変数 `hoge` を宣言し，値 10 を代入します．
```rust
let hoge = 10;
```
スタック上のどこかに値 10 が書き込まれます．このとき，変数 `hoge` はスタック上の値 10 の**所有権**を持っている，あるいは**所有**しているといいます．

次に，変数 `vector` を宣言してベクタ `vec![10, 20, 30]` を代入します．
```rust
let vector = vec![10, 20, 30];
```
ヒープにアロケートされた領域に 3 つの値 10，20，30 が書き込まれます．今度は，変数 `vector` がこのデータの所有権を持っています．

所有関係が多段階になることもあります．例えば，
```rust
let tuple = ([1, 2], vec![1, 2]);
```
というタプルは 2 つの要素 `tuple.0` `tuple.1` を所有し，さらに `tuple.0` がスタック上の値 1，2 を，`tuple.1` がヒープ上の値 1，2 をそれぞれ所有しています．

どの値も，常にただ 1 つの所有者によって所有されています．以下のコードで，ベクタのデータの所有権を持っているのは `vector` だけです． `ref_entire` や `ref_elem` は借用によって得られたアドレス値こそ所有していますが，ベクタの所有権は持っていません．
```rust
fn main() {
    let vector = vec![10, 20, 30];
    let ref_entire = &vector;
    let ref_elem = &vector[1];
}
```
このコードでは， `vector` が使っていたヒープ上の領域が， `main` 関数の最後にデアロケートされます．これを**ドロップ**といいます．

変数は，スコープを抜けるときにドロップされます．そして，所有者がドロップされるとき，所有されている値もドロップされます．
```rust
fn main() {
    {
        let tuple = ([1, 2], vec![1, 2]);
    } // ドロップ
}
```
`tuple` がブロック内で宣言されています．ブロックが終わるとき， `tuple` はスコープを抜けるのでドロップされ， `tuple` の所有する `tuple.0` `tuple.1` もドロップされ，さらにそれぞれの所有するスタックとヒープの値 1，2 もドロップされます．ベクタである `tuple.1` がドロップされるとき，値 1，2 が置かれていたヒープ上の領域がデアロケートされます．

値の所有者は常に 1 つなので，ヒープ上にアロケートされた領域がデアロケートされるのは，所有者がドロップするときの 1 回だけです．

デアロケート済みのメモリにアクセスしたり，再びデアロケートを試みたりしてはいけないのでした．以下のコードを見ながら，そのルールが守られていることを確認しましょう．
```rust
fn main() {
    let ref_elem;
    {
        let vector = vec![10, 20, 30];
        {
            let ref_entire = &vector;
        } // ref_entire は所有権を持っていない
        ref_elem = &vector[1];
    } // デアロケート

    // assert_eq!(*ref_elem, 20);
    // エラー：ここで ref_elem は使えない

} // ref_elem は所有権を持っていない
```
途中で `ref_entire` がスコープを抜けてドロップされていますが， `ref_entire` はヒープ上の値 10，20，30 の所有権を持っていないので，デアロケートは起こりません．

また， `ref_elem` に要素 `vector[1]` への参照が代入されてから `vector` がドロップされてデアロケートが起こりますが，それ以降 `ref_elem` のもつ参照値を使用するのはライフタイムのルールに反するため，デアロケート済みの領域への不正なアクセスは起こりません．

`main` 関数の最後で `ref_elem` がドロップされますが，これも所有者でないのでデアロケートは起こりません．
# ムーブ
再び，ベクタをもつ変数 `vector` を考えます．
```rust
let vector = vec![10, 20, 30];
```
このベクタを， `=` を使って別の変数 `moved` に代入してみます．
```rust
let moved = vector;
```
このとき，ヒープ上の値 10，20，30 の所有権が，変数 `vector` から変数 `moved` に移動します．しかし値の所有者は常に 1 つでなければならないので， `vector` はこのデータへの所有権を失います．このことを， `vector` から `moved` へと値が**ムーブ**されたといいます．

ムーブによって所有権を失った状態の変数は，使用できません．未初期化の変数と似たような状態になります．
```rust:コンパイルエラー
fn main() {
    let vector = vec![10, 20, 30];
    let moved = vector;
    println!("{:?}", vector);
}
```
```:エラーメッセージ
error[E0382]: borrow of moved value: `vector`
 --> src/main.rs:4:22
  |
2 |     let vector = vec![10, 20, 30];
  |         ------ move occurs because `vector` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
3 |     let moved = vector;
  |                 ------ value moved here
4 |     println!("{:?}", vector);
  |                      ^^^^^^ value borrowed here after move
```

ムーブのおかげで，デアロケート済みのメモリにアクセスしたり再びデアロケートを試みたりしてしまうことはありません．
```rust
fn main() {
    let vector = vec![10, 20, 30];
    {
        let moved = vector; // 所有権が移動
    } // デアロケートされる

    // ここで vector は使えない

} // デアロケートされない
```
`vector` から `moved` へ所有権が移動しているので， `moved` がドロップされるときにデアロケートが起こります．ブロックを抜けたあと `vector` は使えないので，デアロケート済みの領域にアクセスしてしまうことはありません．また `main` 関数の最後で `vector` がドロップされますが，このとき `vector` は所有権を持たないので，再びデアロケートを試みてしまうこともありません．

## コピー可能な型
今まで登場した多くの型では，代入後も元の変数を使い続けることができました．
```rust
fn main() {
    let value = 10;
    let copied = value;
    assert_eq!(value, copied); // value も copied も使える
}
```
メモリ上の 2 ヶ所に同じ値 10 があって，それぞれ `value` と `copied` が所有しています．ドロップ時にデアロケーションを行うベクタと違い， `i32` 型の値をコピーした後に元の変数を使い続けることには何の問題もありません．

上のコードがコンパイルできるのは， `i32` が**コピー可能**な型だからです．全ての型はコピー可能な型とコピー不可能な型に分けられ，コピー可能な型同士の代入ではムーブが起こらず，元の変数をその後も使い続けられます．一方ベクタはコピー不可能な型であり，代入によってムーブが起こります．

今までに登場した型について，どれがコピー可能で，どれがコピー不可能かを，以下に示します．

- `i8` `i16` `i32` `i64` `i128` `isize` `u8` `u16` `u32` `u64` `u128` `usize` `f32` `f64` は全てコピー可能です（同様に今後登場する `char` `bool` もコピー可能です）．
- どんな型 `T` についても，不変参照 `&T` はコピー可能です．
- どんな型 `T` についても，可変参照 `&mut T` はコピー*不可能*です．
- どんな型 `T` についても，ベクタ `Vec<T>` はコピー*不可能*です．
- `T` がコピー可能ならば，配列 `[T; N]` もコピー可能です． `T` がコピー不可能ならば，配列 `[T; N]` もコピー不可能です．
- `T` `U` ……が*全て*コピー可能ならば，タプル `(T, U, ...)` もコピー可能です．`T` `U` ……のうち 1 つでもコピー不可能ならば，タプル `(T, U, ...)` はコピー不可能です．ユニット `()` はコピー可能です．

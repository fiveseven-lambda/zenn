---
title: "所有権"
---

# ヒープ
[第 24 章](https://zenn.dev/toga/books/rust-atcoder/viewer/vector)で登場したベクタの要素は，配列と同様，メモリ上で連続した領域に置かれます．これにより，内部ではアドレスの足し算だけで $i$ 番目へのアクセスや `for` 文での走査ができます．

しかし， `push` 関数で要素の追加を繰り返すと，必要なメモリ量が増えてゆきます．そのため，[第 23 章](https://zenn.dev/toga/books/rust-atcoder/viewer/recursion#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF)で説明したスタックの仕組みだけだと，ベクタのためのメモリを管理できません．そこで，**ヒープ**という，メモリ上のスタックとは別の領域を使います．

ヒープを使用するプログラムは，実行しているあいだ常に，ヒープの中で未使用の部分を全て記録しています．ベクタのためのメモリが必要になったら，未使用の部分から一部とって使います．ベクタを使い終わったら，不要になった部分を未使用に戻します．このように，実行中にどこが未使用か記録しながらメモリを管理することを，**動的なメモリアロケーション**といいます．

スタックは，端の場所さえ記録しておけば，次の関数呼び出しで使える領域がすぐ分かります．これに比べて，ヒープにおける動的なメモリアロケーションはより複雑な仕組みを必要とします．しかしそのおかげで，前もって必要なメモリ量を知ることができなくても，実行中必要になったぶんのメモリを得ることができます．

動的なメモリアロケーションは，ベクタではなく，**アロケータ**という裏方が担います．今後ベクタ以外にもヒープを使用するものが登場しますが，皆メモリが必要になるとアロケータを通してメモリを得ます．

以下の図を用いて，ベクタとアロケータのやり取りを説明します．アロケータは，ヒープのどこが未使用か覚えています．
![](/images/heap-allocator.png)

ベクタはメモリが必要になるとアロケータに頼んで，使っていい場所（アドレス）を教えてもらいます．これを**アロケート**といいます．
![](/images/heap-allocate.png)

一方，メモリを使い終わって不要になると，アロケータにそのアドレスを伝えます．これを**デアロケート**といいます．アロケータは，デアロケートされた領域をそれ以降別のアロケートに使えます．
![](/images/heap-deallocate.png)

また，アロケートした後に大きさが足りなくなったら，アロケータにもっと広い空き領域を探してもらいます．これを**リアロケート**といいます．

:::message
実際は，これにくわえて OS によるメモリ管理が関わってきます．
:::

## デアロケート後の注意
アロケータを利用する際に，ベクタなどが注意しなくてはいけないことがあります．それは，メモリをデアロケートした後の取り扱いです．

既にデアロケートした領域は，アロケータが別のアロケートに使ってしまっている可能性があります．よって，デアロケート済みの領域にアクセスしたり，再びデアロケートを試みたりしてはいけません．

しかし，プログラマがベクタを使うたびにこれをいちいち気を付けなければいけないのだとしたら大変です．代わりに，以下で説明する**所有権**のルールが，不正なメモリアクセスをコンパイル時に検出します．

# 所有権
まず，変数 `hoge` を宣言し，値 10 を代入します．
```rust
let hoge = 10;
```
スタック上のどこかに値 10 が書き込まれます．このとき，変数 `hoge` はスタック上の値 10 の**所有権**を持っている，あるいは**所有**しているといいます．

次に，変数 `vector` を宣言してベクタ `vec![10, 20, 30]` を代入します．
```rust
let vector = vec![10, 20, 30];
```
ヒープにアロケートされた領域に 3 つの値 10，20，30 が書き込まれます．今度は，変数 `vector` がこのデータの所有権を持っています．

所有関係が多段階になることもあります．例えば，
```rust
let tuple = ([1, 2], vec![1, 2]);
```
というタプルは 2 つの要素 `tuple.0` `tuple.1` を所有し，さらに `tuple.0` がスタック上の値 1，2 を，`tuple.1` がヒープ上の値 1，2 をそれぞれ所有しています．

どの値も，常にただ 1 つの所有者によって所有されています．以下のコードで，ベクタのデータの所有権を持っているのは `vector` だけです． `ref_entire` や `ref_elem` は借用によって得られたアドレス値こそ所有していますが，ベクタの所有権は持っていません．
```rust
fn main() {
    let vector = vec![10, 20, 30];
    let ref_entire = &vector;
    let ref_elem = &vector[1];
}
```
ベクタのためにアロケートされたヒープ上の領域は，最後にデアロケートされます．このデアロケートが起こるタイミングを決めているのが，以下の**ドロップ**です．
- 変数がドロップされるのは，スコープを抜けるときです．
- 値がドロップされるのは，その所有者がドロップされるときです．

上のコードでは，変数 `vector` が `main` 関数の最後でドロップされるので， `vector` が所有していたベクタもこのときにドロップされます．そして，ベクタはドロップされるときにメモリをデアロケートします．よって， `vector` のためにアロケートされたメモリは， `main` 関数の最後にデアロケートされます．

所有関係が多段階の場合も見てみましょう．
```rust
fn main() {
    {
        let tuple = ([1, 2], vec![1, 2]);
    } // ドロップ
}
```
`tuple` がブロック内で宣言されています．ブロックが終わるとき， `tuple` はスコープを抜けるのでドロップされ， `tuple` の所有する `tuple.0` `tuple.1` もドロップされ，さらにそれぞれの所有するスタックとヒープの値 1，2 もドロップされます． `tuple.1` の所有するベクタがドロップされるとき，値 1，2 が置かれていたヒープ上の領域がデアロケートされます．

値の所有者は常に 1 つなので，ヒープ上にアロケートされた領域がデアロケートされるのは，所有者がドロップするときの 1 回だけです．

デアロケート済みのメモリにアクセスしたり，再びデアロケートを試みたりしてはいけないのでした．以下のコードを見ながら，そのルールが守られていることを確認しましょう．
```rust
fn main() {
    let ref_elem;
    {
        let vector = vec![10, 20, 30];
        {
            let ref_entire = &vector;
        } // ref_entire は所有権を持っていない
        ref_elem = &vector[1];
    } // デアロケート

    // assert_eq!(*ref_elem, 20);
    // エラー：ここで ref_elem は使えない

} // ref_elem は所有権を持っていない
```
途中で `ref_entire` がスコープを抜けてドロップされていますが， `ref_entire` はヒープ上の値 10，20，30 の所有権を持っていないので，デアロケートは起こりません．

また， `ref_elem` に要素 `vector[1]` への参照が代入されてから `vector` がドロップされてデアロケートが起こりますが，それ以降 `ref_elem` のもつ参照値を使用するのはライフタイムのルールに反するため，デアロケート済みの領域への不正なアクセスは起こりません．

`main` 関数の最後で `ref_elem` がドロップされますが，これもベクタの所有者でないのでデアロケートは起こりません．
# ムーブ
再び，ベクタをもつ変数 `vector` を考えます．
```rust
let vector = vec![10, 20, 30];
```
このベクタを， `=` を使って別の変数 `moved` に代入してみます．
```rust
let moved = vector;
```
このとき，ヒープ上の値 10，20，30 の所有権が，変数 `vector` から変数 `moved` に移動します．しかし値の所有者は常に 1 つでなければならないので， `vector` はこのデータへの所有権を失います．このことを， `vector` から `moved` へと値が**ムーブ**されたといいます．

ムーブによって所有権を失った状態の変数は，使用できません．未初期化の変数と似たような状態になります．
```rust:コンパイルエラー
fn main() {
    let vector = vec![10, 20, 30];
    let moved = vector;
    println!("{:?}", vector);
}
```
```:エラーメッセージ
error[E0382]: borrow of moved value: `vector`
 --> src/main.rs:4:22
  |
2 |     let vector = vec![10, 20, 30];
  |         ------ move occurs because `vector` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
3 |     let moved = vector;
  |                 ------ value moved here
4 |     println!("{:?}", vector);
  |                      ^^^^^^ value borrowed here after move
```

ムーブのおかげで，デアロケート済みのメモリにアクセスしたり再びデアロケートを試みたりしてしまうことはありません．
```rust
fn main() {
    let vector = vec![10, 20, 30];
    {
        let moved = vector; // 所有権が移動
    } // デアロケートされる

    // ここで vector は使えない

} // デアロケートされない
```
`vector` から `moved` へ所有権が移動しているので， `moved` がドロップされるときにデアロケートが起こります．ブロックを抜けたあと `vector` は使えないので，デアロケート済みの領域にアクセスしてしまうことはありません．また `main` 関数の最後で `vector` がドロップされますが，このとき `vector` は所有権を持たないので，再びデアロケートを試みてしまうこともありません．

## コピー可能な型
上で，代入によって元の変数が使えなくなる場合を示しました．しかし前の章までそのようなことはありませんでした．
```rust
fn main() {
    let value = 10;
    let copied = value;
    assert_eq!(value, copied); // value も copied も使える
}
```
実は，型には 2 種類あります．それは，**コピー可能**な型と，**コピー不可能**な型です．型がコピー可能かコピー不可能かで， `=` による代入の意味が異なります．

コピー可能な型の場合，代入によってムーブが起こらず，元の変数をその後も使い続けられます．上のコードで代入後も変数 `value` を使えているのは， `i32` がコピー可能な型だからです．代入の後，スタックの 2 ヶ所に同じ値 10 があって，それぞれ `value` と `copied` が所有します．ドロップ時にデアロケートを行うベクタと違い， `i32` 型の値をコピーすることには何の問題もありません．

一方，コピー不可能な型の場合，代入によってムーブが起こります．ベクタは，コピー不可能な型です．

今までに登場した型について，どれがコピー可能で，どれがコピー不可能かを，以下に示します．

- `i8` `i16` `i32` `i64` `i128` `isize` `u8` `u16` `u32` `u64` `u128` `usize` `f32` `f64` は全てコピー可能です（同様に今後登場する `char` `bool` もコピー可能です）．
- どんな型 `T` についても，不変参照 `&T` はコピー可能です．
- どんな型 `T` についても，可変参照 `&mut T` はコピー*不可能*です．
- どんな型 `T` についても，ベクタ `Vec<T>` はコピー*不可能*です．
- `T` がコピー可能ならば，配列 `[T; N]` もコピー可能です． `T` がコピー不可能ならば，配列 `[T; N]` もコピー不可能です．
- `T` `U` ……が*全て*コピー可能ならば，タプル `(T, U, ...)` もコピー可能です．`T` `U` ……のうち 1 つでもコピー不可能ならば，タプル `(T, U, ...)` はコピー不可能です．ユニット `()` はコピー可能です．

# ムーブが起こる他の状況
## 返り値や引数
ブロックや関数が値を返したり，関数が引数を受け取ったりするときも，コピー不可能な型であればムーブが起こります．

まず，返り値でムーブが起こる例です．ブロックの場合と関数の場合で 1 つずつ示します．
```rust
fn main() {
    let digits = {
        let mut tmp = Vec::new();
        for i in 0..10 {
            tmp.push(i);
        }
        tmp
    };
    println!("{:?}", digits);
}
```
```rust
fn main() {
    let digits = sequence(10);
    println!("{:?}", digits);
}

fn sequence(n: usize) -> Vec<usize> {
    let mut ret = Vec::new();
    for i in 0..n {
        ret.push(i);
    }
    ret
}
```
どちらの例においても，ブロックか関数の最後で，ベクタの所有権が変数 `digits` へ移動します．よって， `main` 関数の最後までメモリのデアロケートは起こりません．

次に，関数の引数でムーブが起こる例です．
```rust
fn main() {
    let test_scores = vec![82, 91, 79];
    let total_score = sum(test_scores); // ムーブ
    // ここで test_scores は使えない
    // assert_eq!(test_scores[0], 82); エラー
    assert_eq!(total_score, 252);
}

fn sum(vector: Vec<i32>) -> i32 {
    let mut ret = 0;
    for elem in &vector {
        ret += elem;
    }
    ret
}
```
`sum` 関数の呼出しで， `main` 関数内の変数 `test_scores` から `sum` 関数の引数 `vector` へ所有権が移動します． `sum` 関数が終わるとき， `vector` がドロップして，メモリがデアロケートされます． `sum` 関数から `main` 関数に戻ったとき，もはや `test_scores` は所有権を失っており，使えません．

## タプル
タプルの要素にコピー不可能なものが含まれていると，タプル自体もコピー不可能になります．よって，以下のコードはコンパイルエラーになります．
```rust:コンパイルエラー
fn main() {
    let tuple: (Vec<i32>, i32) = (vec![], 7);
    let moved = tuple; // ムーブ
    assert_eq!(tuple.1, 7); // エラー
}
```
`Vec<i32>` がコピー不可能な型なので， `(Vec<i32>, i32)` もコピー不可能な型です．そのため代入によって `tuple` から `moved` へムーブが起こります．このとき `i32` 型の `tuple.1` も一緒に使えなくなります．

タプルを作る際にも，ムーブが起こります．
```rust:コンパイルエラー
fn main() {
    let vector = vec![];
    let tuple: (Vec<i32>, i32) = (vector, 10); // ムーブ
    println!("{:?}", vector); // エラー
}
```
ベクタが `vector` から `tuple.0` へムーブされます．

また，タプルの一部だけをムーブすることも可能です．
```rust
fn main() {
    let tuple = (vec![10, 20, 30], 7);
    let vector = tuple.0; // 一部をムーブ
}
```
ベクタが `tuple.0` から `vector` へムーブされるので，このあと `tuple.0` は使えません．しかし，*`tuple.1` はその後も使い続けられます*．
```rust
fn main() {
    let tuple = (vec![10, 20, 30], 7);
    let vector = tuple.0; // 一部をムーブ
    // assert_eq!(tuple.0[0], 10); エラー
    assert_eq!(tuple.1, 7); // 使用できる
}
```
# ムーブができない状況
## ベクタの要素
`Vec<Vec<i32>>` という型を考えます．これはベクタのベクタです．

`vec!` マクロを使って `Vec<Vec<i32>>` 型の値を作ると，たとえば次のようになります．
```rust
let vector: Vec<Vec<i32>> = vec![vec![2, 3, 4], vec![1], vec![0; 5]];
```

`vector` の型が `Vec<Vec<i32>>` なので， `vector[0]` `vector[1]` `vector[2]` の型は全て `Vec<i32>` になります． `vector[0]` は `vec![2, 3, 4]` に， `vector[1]` は `vec![1]` に， `vector[2]` は `vec![0; 5]` （`vec![0, 0, 0, 0, 0]`）にそれぞれ等しくなります．よって
```rust
fn main() {
    let vector: Vec<Vec<i32>> = vec![vec![2, 3, 4], vec![1], vec![0; 5]];
    for i in &vector[0] {
        println!("{}", i);
    }
}
```
と書けば
```:stdout
2
3
4
```
と出力されますし，
```rust
fn main() {
    let vector: Vec<Vec<i32>> = vec![vec![2, 3, 4], vec![1], vec![0; 5]];
    for i in &vector {
        for j in i {
            print!("{} ", j);
        }
        println!();
    }
}
```
と書けば
```:stdout
2 3 4 
1 
0 0 0 0 0 
```
と出力されます．

`Vec<T>` の `T` がコピー可能でない場合，*ベクタから要素だけをムーブすることはできません*．よって次のコードはエラーになります．
```rust:コンパイルエラー
fn main() {
    let vector: Vec<Vec<i32>> = vec![vec![2, 3, 4], vec![1], vec![0; 5]];
    let moved = vector[0]; // エラー：ムーブできない
}
```
`vector` というベクタ全体ではなく，その要素である `vector[0]` のみを `moved` にムーブしようとしています． `vector` は，常に「ベクタ全体への所有権を持っている」か「一切所有権を持っていない」のいずれかであり，ベクタの一部を所有していることはありません．

ここで，先ほどのコードの
```rust
for i in &vector {
    for j in i {
        print!("{} ", j);
    }
    println!();
}
```
の部分を，型に着目して見てみましょう． `for` 式では， `in` の後に `&[T; N]` や `&Vec<T>` や `&[T]` を置くと，各要素への参照 `&T` が走査されます．今回， `&vector` の型は `&Vec<Vec<i32>>` なので， `i` の型は `&Vec<i32>` になり， `j` の型は `&i32` になります．

これを，次のように書いてしまうとエラーになります．
```rust:コンパイルエラー
for &i in &vector { // エラー：ムーブ
    for j in &i {
        print!("{} ", j);
    }
    println!();
}
```
`Vec<i32>` 型の変数 `i` に，ベクタ `vector` の要素をムーブすることになるからです．

# 確認問題
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let vector = vec![1, 2, 3];
       let moved = vector;
       let moved_2 = vector;
   }
   ```
   :::details 答え
   `let moved_2 = vector;` で**エラー**になります．ムーブされた後の `vector` を使用しようとしているためです．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let vector = vec![1, 2, 3];
       let moved = vector;
       let reference = &vector;
   }
   ```
   :::details 答え
   `&vector` で**エラー**になります．ムーブ後は，使用も借用もできません．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let tuple = (vec![0], 10);
       let (v, x) = tuple;
       assert_eq!(tuple.1, 10);
   }
   ```
   :::details 答え
   **動きます**．
   
   パターンマッチで， `tuple` の要素がそれぞれ `v` と `x` に代入されます．このうちムーブが起こるのは `tuple.0` から `v` だけなので，これはタプルの部分的なムーブとなり， `tuple.1` はその後も使えます．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let vector = vec![1, 2, 3];
       let reference = &vector[0];
       let moved = vector;
       assert_eq!(*reference, 1);
   }
   ```
   :::details 答え
   **エラー**になります．変数が借用されている間に，ムーブを行って変数から所有権を奪うことはできません．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let vector = vec![1, 2, 3];
       let reference = &vector;
       let moved = *reference;
   }
   ```
   :::details 答え
   **エラー**になります． `reference` という参照を通して， `vector` の所有権を奪うことはできません．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let reference;
       let vector = {
           let v = vec![10, 20, 30];
           reference = &v;
           v
       };
   }
   ```
   :::details 答え
   **動きます**．
   
   `v` から `vector` へムーブが起こりますが，*このとき既に `reference` のライフタイムは終了しています*．
   
   ブロックの後に `println!("{:?}", reference);` などを付け加えるとエラーになります．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let reference;
       let vector = {
           let v = vec![10, 20, 30];
           reference = &v;
           *reference
       };
   }
   ```
   :::details 答え
   **エラー**になります． `reference` のライフタイムが， `v` のスコープをはみ出そうとしています．
   :::
1. 次のコードは正常に動くでしょうか．
   ```rust
   fn main() {
       let vector = vec![
           (vec![5, 2], 3.5),
           (vec![1, 4, 3, 3], 2.75),
           (vec![4, 6], 5.),
       ];
       for &(v, mean) in &vector {
           println!("{:?}: {}", v, mean);
       }
   }
   ```
   :::details 答え
   **エラー**になります．
   
   `vector[0].0` / `vector[1].0` / `vector[2].0` から `vec` へベクタをムーブしようとしているためです．パターンを `&(ref v, mean)` あるいは `(v, mean)` に変えると動きます．
   :::
---
title: "参照を返す関数"
---
# 参照を返す関数
関数が参照を返すことを考えます．

どんな参照値も，必ず何かの変数を借用することによって得られます．よって，関数が参照を返すとしたら，借用元の変数がどこかに存在するはずです．

しかし，関数の中で宣言された変数は，関数の終了とともにスコープが終了するので，その参照を返り値とすることはできません．よって，関数が参照を返せるのは次のいずれかの場合に限られます：

- 関数が引数として参照を受け取っている場合．
- 返り値となる参照が静的なライフタイムをもつ場合．

# 引数として参照を受け取っている場合


`&[i32]` 型のスライス参照 `slice` を受け取って，前半部分のスライスと後半部分のスライスを返す `split_mid` 関数を考えます．まず，この処理を関数として切り出さずにブロックとして書くと次のようになります．

```rust
fn main() {
    let vec = vec![3, 1, 4, 1, 5, 9];
    let slice = &vec[..];
    let (former, latter) = {
        let mid = slice.len() / 2;
        // 今回 slice.len() は 6 なので
        // mid は 3 になる
        (&slice[..mid], &slice[mid..])
    };
    assert_eq!(former, [3, 1, 4]);
    assert_eq!(latter, [1, 5, 9]);
}
```

`slice` は `vec` への参照なので， `slice` のライフタイムは `vec` のスコープをはみ出てはいけません．一方， `former` と `latter` もそれぞれ `vec` の一部への参照となるので，同じく `vec` のスコープをはみ出ることができません．

このように， `&slice[..mid]` や `&slice[mid..]` という形で `slice` の借用元である `vec` を再び借用している限り， `former` と `latter` のライフタイムは `slice` のライフタイムの限界を超えることができません．

このブロックを `split_mid` 関数として切り出すときの書き方は，次のようになります．
```rust
fn split_mid<'a>(slice: &'a [i32]) -> (&'a [i32], &'a [i32]) {
    let mid = slice.len() / 2;
    (&slice[..mid], &slice[mid..])
}
```
ジェネリクスのときと同じように，関数名 `split_mid` の後に山括弧で括られた部分 `<'a>` が続いています．この `'a` が，ライフタイムに対して付けられる名前，**ライフタイムパラメータ**です．ライフタイムパラメータは，ループに付けるラベルと同じくアポストロフィ `'` で始め， `&[i32]` や `&mut (f64, bool)` といった型名の `&` の直後に付けて `&'a [i32]` や `&'b mut (f64, bool)` のように使います．

今回，関数は 2 つの参照値をタプルとして返しており，それぞれにライフタイムパラメータ `'a` が付いています．一方関数の引数を見ると，同じライフタイムパラメータ `'a` の付いた参照 `slice` があります． `main` 関数の中でこの `split_mid` 関数を `split_mid(slice)` のように呼び出したとき，返された参照値のライフタイムは， `slice` のライフタイムの限界を超えることができません．

参照を返す関数は，このように，返り値となる各々の参照についてライフタイムの限界を明確にしなければいけません．

まず，これはコンパイルが通る例です：
```rust
fn main() {
    let vec = vec![3, 1, 4, 1, 5, 9];
    let slice = &vec[..];
    let (former, latter) = split_mid(slice);
    assert_eq!(former, [3, 1, 4]);
    assert_eq!(latter, [1, 5, 9]);
}
```
`slice` は `vec` への参照なので，そのライフタイムは `main` 関数の終わりまで伸ばすことが可能です．すると `split_mid` 関数の返した `former` `latter` のライフタイムも同じく `main` 関数の終わりまで伸ばすことが可能となるので， 2 つの `assert_eq!` は問題なく実行できます．

一方，これはコンパイルが通らない例です：
```rust
fn main() {
    let split;
    {
        let vec = vec![3, 1, 4, 1, 5, 9];
        let slice = &vec[..];
        split = split_mid(slice); // slice の最後の使用
    } // vec のドロップ
    assert_eq!(split.0, [3, 1, 4]); // split.0 の最後の使用
    assert_eq!(split.1, [1, 5, 9]); // split.1 の最後の使用
}
```
今度は `vec` が `main` 関数の途中でドロップします． `slice` は最後の使用がブロック内なので問題ありませんが， `split` はブロック外で使用されてしまっています． `slice` のライフタイムが伸ばせる限界はブロックの終了までだったので， `split` のライフタイムもブロックからはみ出ることができず，このコードはエラーになります．

問題です．同じ `split_mid` 関数を使った次のコードは，コンパイルエラーになるでしょうか？
```rust
fn main() {
    let vec = vec![3, 1, 4, 1, 5, 9];
    let split;
    {
        let slice = &vec[..];
        split = split_mid(slice);
    }
    assert_eq!(split.0, [3, 1, 4]);
    assert_eq!(split.1, [1, 5, 9]);
}
```
:::details 答え
**コンパイルエラーにはなりません**． `slice` 自体のスコープはブロックの終わりまでですが，そのライフタイムを伸ばせる限界は `vec` がドロップされる `main` 関数の終わりまでなので， `split` のライフタイムもそこまで伸ばすことができます．
:::

## 引数として受け取る参照が複数ある場合
次の関数は，可変なスライス参照 `x: &mut [i32]` と不変なスライス参照 `y: &[i32]` を受け取って，スライス参照 `&[i32]` を返しています．返り値 `&x[0..len]` のライフタイムは `x` のライフタイムと同じだけ伸ばすことができるので，返り値と `x` に同じライフタイムパラメータ `'a` を付けます．
```rust
fn main() {
    let mut a = vec![3, 1, 4, 1, 5];
    let b = vec![2, 7, 1];
    assert_eq!(add(&mut a, &b), &[5, 8, 5]);
}

fn add<'a>(x: &'a mut [i32], y: &[i32]) -> &'a [i32] {
    let len = x.len().min(y.len());
    for i in 0..len {
        x[i] += y[i];
    }
    &x[0..len]
}
```

一方，次の関数は， 2 つのスライス参照 `x: &[i32]` `y: &[i32]` を受け取って，スライス参照 `&[i32]` を返す関数です．この関数は `x` を返すことも `y` を返すこともあるので，返り値と `x` と `y` に全て同じライフタイムパラメータを付けています．
```rust
fn longer<'a>(x: &'a [i32], y: &'a [i32]) -> &'a [i32] {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
この `longer` 関数を次のように使おうとするとエラーになります．
```rust
fn main() {
    let a = vec![1, 2, 3, 4];
    let c;
    {
        let b = vec![1, 2, 3];
        c = longer(&a, &b);
    }
    assert_eq!(c, [1, 2, 3, 4]); // エラー
}
```
`longer` 関数の返り値に付けられたライフタイムパラメータは `x` と同じなので， `c` のライフタイムは `&a` のライフタイムの限界を超えることができません．しかし `a` のスコープは `main` 関数の終わりまで続くので問題ありません．

一方， `longer` 関数の返り値に付けられたライフタイムパラメータは `y` とも同じなので， `c` のライフタイムは `&b` のライフタイムの限界も超えることができません． `b` のスコープはブロックの終了とともに終わるので，それ以降 `c` を使うことはできず，コンパイルエラーになります．

## ライフタイムパラメータの省略
関数が引数として受け取っている参照値が 1 つしかない場合は，ライフタイムパラメータを省略することができます．

```rust
fn fnc<'a>(s: &'a mut String, c: char) -> &'a str {
    s.push(c);
    s
}
```
引数として `s` と `c` の 2 つを受け取っており，そのうち参照であるようなものは `c` 1 つだけなので，ライフタイムパラメータを省略して次のように書くことができます．
```rust
fn fnc(s: &mut String, c: char) -> &str {
    s.push(c);
    s
}
```
# 返り値が静的なライフタイムをもつ場合

# 型とライフタイムを明示するということ
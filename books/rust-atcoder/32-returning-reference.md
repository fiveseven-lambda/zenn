---
title: "参照を返す関数"
---
# 参照を返す関数
関数が参照を返すことを考えます．

どんな参照値も，必ず何かの変数を借用することによって得られます．よって，関数が参照を返すとしたら，借用元の変数がどこかに存在するはずです．

しかし，関数の中で宣言された変数は，関数の終了とともにスコープが終了するので，その参照を返り値とすることはできません．よって，関数が参照を返せるのは次のいずれかの場合に限られます：

- 関数が引数として参照を受け取っている場合．
- 返り値となる参照が静的なライフタイムをもつ場合．

# 引数として参照を受け取っている場合
## ライフタイムパラメータ
整数の列 $a_0, a_1, \ldots, a_{n - 1}$ の中から， $a_0 < a_1 < \cdots < a_i$ となっている最も長い部分列 $a_0, a_1, \ldots, a_i$ を探す関数を考えます．言い換えると， `&[i32]` 型のスライス参照 `slice` を受け取って，その先頭からの部分スライス `slice[..=i]` の中で単調に増加するような最長のものへの参照を返す関数です．たとえば，受け取ったスライス参照が `&[2, 4, 7, 8, 6, 3, 5]` であれば，返り値は `&[2, 4, 7, 8]` となります．

まず，この処理を関数として切り出さずに書くと次のようになります．

```rust
fn main() {
    let vec = vec![2, 4, 7, 8, 6, 3, 5];
    let slice = &vec[..];
    let mut increasing = slice;
    for i in 0..slice.len() - 1 {
        if slice[i] >= slice[i + 1] {
            increasing = &slice[..=i];
            break;
        }
    }
    assert_eq!(increasing, &[2, 4, 7, 8]);
}
```

:::message
`vec![2, 4, 7, 8, 6, 3, 5]` を `vec![1, 2, 3, 4, 5]` や `vec![10]` や `vec![]` に変えても正しく動くか，理由とともに考えてみましょう．
:::

ここで，コード中に現れた各々の参照が，ライフタイムをどこまで伸ばせるか考えます．

まず， `slice` は `vec` への参照なので， `slice` のライフタイムが `vec` のスコープをはみ出てはいけません．よって， `slice` のライフタイムの限界は `vec` のスコープの終わりまでとなります．今回の場合は `main` 関数の最後までです．

一方， `increasing` ももとを辿れば `vec` への参照なので，ライフタイムの限界は同じく `vec` のスコープの終わりまでとなります． `increasing` には， `slice` そのものか， `slice` を通して得たスライス（ `slice[..=i]` ）への参照しか代入していないので，そのライフタイムの限界も当然 `slice` と同じになるわけです．

さて，次にこれを関数として切り出します．このとき，次のルールに従わなければなりません．

- 関数の返り値に参照が含まれるときは，含まれる全ての参照のライフタイムをそれぞれ明確にしなければいけない．

今回は返り値が参照 `&[i32]` なので，このルールの対象は返り値そのものとなります．もし返り値が `(usize, &[i32], &str)` のような形で複数の参照を含んでいれば， `&[i32]` `&str` ともにこのルールの対象となります．

では，ライフタイムを明確にするためには，具体的に何をすればよいのでしょう．このときに用いるのが，ライフタイムに対して付けられる名前，**ライフタイムパラメータ**です．まずは，先ほどの処理を関数 `increasing` として切り出した結果を見てください．

```rust
fn increasing<'a>(slice: &'a [i32]) -> &'a [i32] {
    let mut ret: &'a [i32] = slice;
    for i in 0..slice.len() - 1 {
        if slice[i] >= slice[i + 1] {
            ret = &slice[..=i];
            break;
        }
    }
    ret
}
```

4 箇所に書かれた `'a` が，この関数の返り値のライフタイムを説明するためのライフタイムパラメータです．

- 関数名 `increasing` の直後の `<'a>`．
- 引数 `slice` の型 `&'a [i32]`．
- 返り値の型 `&'a [i32]`．
- 関数内の変数 `ret` の型 `&'a [i32]`．

ライフタイムパラメータは，ループに付けるラベルと同じくアポストロフィ `'` で始め， `&[i32]` や `&mut Vec<f64>` といった型名の `&` の直後に付けて `&'a [i32]` や `&'b mut Vec<f64>` のように使います．
:::message
`&slice[..=i]` のように，型名ではなく変数名の前にある `&` には，ライフタイムパラメータを付けません．
:::

ジェネリクスにおいては，関数を定義するとき名前の直後に `<T>` と付けると，関数の中で型パラメータ `T` が使えるようになりました．同じように，参照を返す関数を定義するときも，名前の直後に `<'a>` を付けることでライフタイムパラメータ `'a` が使えるようになります．型パラメータもライフタイムパラメータも一度に複数使えますが，同時に使うときは `<T, U, 'a, 'b>` のように「型パラメータ→ライフタイムパラメータ」の順番で書かなければいけません．

同じライフタイムパラメータが付いた参照は，全て同じライフタイムを持ちます．上の `increasing` 関数であれば， `slice`， `ret`，そして返り値は全て同じライフタイムを持つわけです．こうして，「返り値は，引数 `slice` と同じライフタイムを持つ」ということを明示すると，返り値のライフタイムを明確にできたことになります．

こうして定義した `increasing` 関数を使うときは，次のようになります．

```rust
fn main() {
    let vec = vec![2, 4, 7, 8, 6, 3, 5];
    let result = increasing(&vec);
    assert_eq!(result, &[2, 4, 7, 8]);
}
```

引数として `&vec` を渡し，返り値を `result` に代入しています．上で明示した通り， `increasing` 関数の引数と返り値のライフタイムは同じなので， `result` のライフタイムは `vec` のスコープ，すなわち `main` 関数の終わりまで続くことができます．

よって， `increasing` 関数を次のように使おうとするとコンパイルエラーになります．
```rust:コンパイルエラー
fn main() {
    let result;
    {
        let vec = vec![2, 4, 7, 8, 6, 3, 5];
        result = increasing(&vec);
    }
    assert_eq!(result, &[2, 4, 7, 8]);
}
```
```
error[E0597]: `vec` does not live long enough
 --> src/main.rs:5:29
  |
5 |         result = increasing(&vec);
  |                             ^^^^ borrowed value does not live long enough
6 |     }
  |     - `vec` dropped here while still borrowed
7 |     assert_eq!(result, &[2, 4, 7, 8]);
  |     ---------------------------------- borrow later used here
```

問題です．同じ `increasing` 関数を使った次のコードは，コンパイルエラーになるでしょうか？
```rust
fn main() {
    let vec = vec![2, 4, 7, 8, 6, 3, 5];
    let result;
    {
        let slice = &vec[..];
        result = increasing(slice);
    }
    assert_eq!(result, &[2, 4, 7, 8]);
}
```
:::details 答え
**コンパイルエラーにはなりません**． `slice` という参照型の「変数」自体のスコープはブロックの終わりまでですが，その中に入っている参照型の「値」のライフタイムは `vec` がドロップされる `main` 関数の終わりまで伸ばすことができます．
:::

## 引数として受け取る参照が複数ある場合
次の関数は，可変なスライス参照 `x: &mut [i32]` と不変なスライス参照 `y: &[i32]` を受け取って，スライス参照 `&[i32]` を返しています．返り値が `&x[0..len]` なので，返り値と `x` に同じライフタイムパラメータ `'a` を付けます．
```rust
fn add<'a>(x: &'a mut [i32], y: &[i32]) -> &'a [i32] {
    let len = x.len().min(y.len());
    for i in 0..len {
        x[i] += y[i];
    }
    &x[0..len]
}
```

一方，次の関数は， 2 つのスライス参照 `x: &[i32]` `y: &[i32]` を受け取って，スライス参照 `&[i32]` を返す関数です．この関数は `x` を返すことも `y` を返すこともあるので，返り値と `x` と `y` に全て同じライフタイムパラメータを付けています．
```rust
fn longer<'a>(x: &'a [i32], y: &'a [i32]) -> &'a [i32] {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
この `longer` 関数を次のように使うと，
```rust
fn main() {
    let four = vec![1, 2, 3, 4];
    let result;
    {
        let three = vec![1, 2, 3];
        result = longer(&four, &three);
        assert_eq!(&four, result);
    }
    // ここで result は使えない
}
```
ライフタイム `'a` は， `&four` と `&three` のうち短い方（ `&three` ）になります．

## ライフタイムパラメータの省略
次の `split_mid` 関数は，スライス参照 `&[i32]` を受け取って，前半部分と後半部分を返す関数です．

```rust
fn main() {
    let (former, latter) = split_mid(&[3, 1, 4, 1, 5, 2]);
    assert_eq!(former, &[3, 1, 4]);
    assert_eq!(latter, &[1, 5, 2]);
}

fn split_mid<'a>(slice: &'a [i32]) -> (&'a [i32], &'a [i32]) {
    let mid = slice.len() / 2;
    (&slice[..mid], &slice[mid..])
}
```

このように，引数に含まれる参照が 1 つしかない場合は，ライフタイムパラメータを省略して次のように書くことができます．

```rust
fn split_mid(slice: &[i32]) -> (&[i32], &[i32]) {
    let mid = slice.len() / 2;
    (&slice[..mid], &slice[mid..])
}
```
`(&[i32], &[i32])` の 2 つの参照にライフタイムパラメータが付いていませんが，引数に含まれる参照が `&[i32]` の 1 つしかないため，これと同じライフタイムをもつとされます．

# 返り値が静的なライフタイムをもつ場合
ライフタイムパラメータ `'static` は，参照が静的なライフタイムをもつことを表します．次の関数は，英語の序数（ 1st, 2nd, 3rd, … ） に付く接尾辞を返す関数です．いずれの場合も静的なライフタイムをもつ文字列スライス参照を返すので，返り値の型は `&'static str` となっています．

```rust
fn ordinal_suffix(number: u32) -> &'static str {
    match (number % 10, number % 100) {
        (_, 11..=13) => "th",
        (1, _) => "st",
        (2, _) => "nd",
        (3, _) => "rd",
        _ => "th",
    }
}
```
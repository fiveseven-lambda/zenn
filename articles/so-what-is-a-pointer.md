---
title: "C/C++の「ポインタ」とは"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["c", "cpp"]
published: true
---

C/C++ の「ポインタ」は、難しいとか、実は簡単だとか、色々言われます。

ポインタについては規格に書かれています。この記事は、ポインタをより正確にイメージするため、規格に私の解釈を追加したものです。区別のため、C++23 草案 (N4950) の内容には節番号を付け、私の解釈は _斜体_ で書きます。

私の解釈は以下の記事の影響を受けています。
https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html

# ポインタとは、IDとオフセットの組
まず、_ヌル以外のポインタは、以下の ID とオフセットの組_ です。

- ID：新しいオブジェクトが作られるたびに振られる、ユニークな値。
- オフセット：オブジェクト先頭からのバイト数。

詳しく話していきます。

## ID の割り振り
変数を定義するとオブジェクトが作られ (6.7.2)、_各オブジェクトに固有の ID が割り振られます_。たとえば、
```cpp
int x, arr[10];
```
と書くと整数 `x` と配列 `arr` が作られるので、`x` と `arr` にそれぞれ ID が振られます。ユニークなので、`x` の ID と `arr` の ID は異なります。

ただし、ID が振られるのは変数として定義した `x` と `arr` だけで、要素 `arr[0]` `arr[1]` … `arr[9]` に固有の ID は振られません。構造体でも同様で、
```cpp
struct { int x, y; } foo;
```
と書けば `foo` に ID が振られますが、`foo.x` と `foo.y` には振られません。

`arr[5]` や `foo.x` のように要素やメンバーとして含まれるオブジェクトをサブオブジェクトといい、そうでない `arr` や `foo` を完全なオブジェクトといいます (6.7.2)。_ID は、完全なオブジェクトだけに振られます_。

_`new` を用いてオブジェクトを作っても、同様に ID が割り振られます_。
```cpp
int *ptr = new int;
ptr = new int;
```
`new` を書くたびに新しいオブジェクトが作られ、異なる ID が振られます。ここでも、振られる ID は 1 度の `new` につき 1 つだけで、サブオブジェクトには振られません。

## オフセット
完全なオブジェクトは、正のサイズを持ちます。サイズは `sizeof` 演算子で得られます。
```cpp
int arr[10];
std::cout << sizeof(arr) << std::endl;
```

私の環境では `int` が 4 バイトなので、40 と出力されました（以下 `int` を 4 バイトとして話を進めます）。

_この 40 バイトのうちどこか 1 箇所（末尾の直後も可）を指すのが、ポインタです。完全なオブジェクトの中で位置の指定に使う値を、オフセットと呼びます_。

たとえばポインタが「`arr` の ID」と「オフセット 0」の組み合わせなら、`arr` の 0 バイト目、つまり先頭を指します。これは `arr` 自体で表されます。

一方ポインタが「`arr` の ID」と「オフセット 20」の組み合わせなら、`arr` の 20 バイト目、つまり（0 始まりで）5 番目の要素を指します。これは、足し算 `arr + 5` で得られます。

「末尾の直後も可」というのは、オフセットが 40 でもよいという意味です。`arr` は 40 バイトしかないので、40 バイト目は存在しない 10 番目の要素ですが、特別に `arr` 末尾の直後のみ許されています。もちろん 41 バイト目や -1 バイト目はなく、オフセットは常に 0 以上 40 以下の値です。

実際に書くとこうなります。
```cpp
int arr[10];
int *p = arr;   // 「arr の ID」と「オフセット 0」
int *q = p + 5; // 「arr の ID」と「オフセット 20」
int *r = q + 5; // 「arr の ID」と「オフセット 40」
```

`arr + 11` や `arr - 1` を計算しようとすると違法（未定義動作）です (7.6.6)。

配列以外でも同様です。
```cpp
int x;          // サイズ 4
int *p = &x;    // 「x の ID」と「オフセット 0」
int *q = p + 1; // 「x の ID」と「オフセット 4」
```

```cpp
struct { int x, y; } foo; // サイズ 8（とします）
int *p = &foo.x;          // 「foo の ID」と「オフセット 0」
int *q = &foo.y;          // 「foo の ID」と「オフセット 4」
```
# ヌルポインタ
どのポインタとも異なる、ヌルポインタ `nullptr` という特別なポインタがあります。

足し算 `nullptr + 0` ができることから、サイズ 0 の仮想的なオブジェクトの ID とオフセット 0 の組と考えても良いですが、そうすると `nullptr` は完全なオブジェクトの末尾の直後を指すことにもなり、以下で都合が悪いので、_ID とオフセットの組という形ではない特別なポインタ_ ということにしておきます。

# `==` `!=` による比較
ポインタ同士は `==` `!=` で比較できます。ここに未定義動作はありません (7.6.10)。

_原則として、2 つのポインタが等しいというのは、ID とオフセットがともに等しいという意味です_。

_ただし例外があって、以下を全て満たす場合は結果が未規定です_。
- _ID が異なる_。
- _片方のオフセットが 0_。
- _もう片方のオフセットがサイズと同じ（つまり末尾の直後）_。

なぜこのような例外があるのでしょうか？それは最適化のためです。

ID とオフセットを別々に扱うと、各操作につき大変コストがかかるので、コンパイラは ID とオフセットをまとめて 1 つの整数値で表すように翻訳します。この過程で、ある完全オブジェクトの末尾の直後を指すポインタと、別の完全オブジェクトの先頭を指すポインタが、同じ整数値に対応してしまうことがあります。そこで規格は、プログラマーに対し「末尾の直後と先頭を比較しても結果に期待するな」と言うことで、コンパイラがより効率的なプログラムを生成することを許したのです。

サイズが 0 のオブジェクトが基本的に作れないのも、このためでしょう。

また、`nullptr == nullptr` は常に真で、`nullptr == (nullptr以外)` は常に偽です。コンパイラは、好きな整数値を `nullptr` に割り当てておき、どのオブジェクトとも被らないようにすれば OK です。
# `<` `>` `<=` `>=` による比較
ポインタ同士の大小は `<` `>` `<=` `>=` で比較できますが、_基本的には同じ ID のときにオフセットの大小を比較するものです_。

同じ配列中の 2 つの要素を指すポインタを比較すれば、ID が同じなので、添字が小さい方が小さく、添字が大きい方が大きくなります。また同じ構造体の 2 つのメンバーを指すポインタを比較すれば、ID が同じなので、前の方が小さく、後の方が大きくなります（ここでいう前後は、構造体を定義するときに宣言した順番です）。

一方、ID が異なる 2 つのポインタの大小比較については、矛盾が生じない（たとえば `p < q` と `q < r` と `r < p` は同時に成り立たない）ことが保証されていますが、その具体的な結果は未規定です。`nullptr` とそれ以外の大小比較も未規定です。

# オブジェクトの生存期間
上で挙げたような変数宣言や `new` でオブジェクトが作られると、オブジェクトの生存期間（ライフタイム）が始まります (6.7.3)。

変数のスコープを抜けたり `delete` を呼んだりしてオブジェクトが破棄されると、生存期間は終了します。

上で話した、`==` `!=` `<` `>` `<=` `>=` によるポインタ同士の演算は、たぶん生存期間中のみ有効……だと思いますが、自信ありません。以下の記述がそうだと思います。
> 6.7.3 Lifetime [basic.life]
> 4. The properties ascribed to objects and references throughout this document apply for a given object or reference only during its lifetime.

# 整数とのキャスト
ポインタと整数の間でキャストができますが、`0` が `nullptr` になることを除いて処理系定義です (7.6.1.10)。

しかし、`size_t` が十分に大きいとして、 `int x;` に対して `(int *)(size_t)&x` が元の値 `&x` に戻ってくることは保証されています。おかげで、[XOR linked list](https://en.wikipedia.org/wiki/XOR_linked_list) が実装できます。

先頭で紹介した記事 "Pointers Are Complicated, or: What's in a Byte?" ではポインタと整数のキャストを未解決の問題点と指摘していますが、処理系定義なら別に良いんじゃないかと個人的には思います。

